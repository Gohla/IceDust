module generating/webdsl/module

imports // constructors

  webdsl/constructors
  webdsl/WebDSL
  desugaring/constructors
  signatures/Types-sig
  analysis2/path
  tiersplit/constructors

imports // functions
  
  generating/_ir/model 
  generating/webdsl/model
  generating/webdsl/data
  generating/webdsl/types
  api/model-names-api
  api/module-api
  api/module-names-api
  lib/lists-tuples
  lib/string

rules // module

  modulename-to-webdsl-application(err): x_moduleName -> result
    where
      <is-modulename> x_moduleName
    with
      def_model*     := <modulename-get-entitynames; map(model-entityname-to-webdsl-def(err))>x_moduleName;
      def_crud*      := <modulename-get-entitynames;fmap(entityname-to-webdsl-defs)>x_moduleName;
      elem_menu*     := <modulename-get-entitynames; map(entityname-to-webdsl-elem)>x_moduleName;
      stat_initdata* := <data-modulename-to-webdsl-stms(err)>x_moduleName
    with
      if (modulename-is-calconwrite<+modulename-is-eventuallyconsistent) then
        def_dirtyReqVar* := <modulename-get-attributenames-default-derivation;map(attributename-to-webdsl-def)>x_moduleName;
        stat_cach*       := <cache-modulename-to-webdsl-stms>x_moduleName
      end
      with
        if modulename-is-eventuallyconsistent then
          stat_flagasync*    := <modulename-get-attributenames-default-derivation;map(attributename-to-webdsl-stat)>x_moduleName;
          native1*           := <modulename-get-attributenames-default-derivation;map(attributename-to-webdsl-native)>x_moduleName;
          stat_cachAsync*    := <cache-async-modulename-to-webdsl-stms>x_moduleName
        end
      with
        sec_modelDataUi* := section* |[
          section data
            
            init {
              stat_initdata*
            }
          
          section model
          
            def_model*
          
          section ui
          
            define applicationmenu() {
              elem_menu*
            }
            
            def_crud*
        ]|
      with
        if modulename-is-calconwrite  then  
          sec_cachesDirtyflag* := section* |[
            section caches and dirty flags
            
              def_dirtyReqVar*
              
              function updateDerivations(){
                stat_cach*
              }
          ]|
        else if modulename-is-eventuallyconsistent then  
          sec_cachesDirtyflag* := section* |[
            section caches and dirty flags
            
              def_dirtyReqVar*
          ]|
        else
          sec_cachesDirtyflag* := []
        end end
      with
        if modulename-is-eventuallyconsistent then
          sec_asyncDirtyflag* :=  section* |[
            section async dirty flags
              
              function flagDirtyAsync(){
                stat_flagasync*
              }
              
              function updateDerivationsAsync(){
                stat_cachAsync*
              }
              
              invoke updateDerivationsAsync() every 1 milliseconds
              
              native class derivations.DirtyCollections as DirtyCollections {
                native1*
              }
              
              native class java.util.Queue as Queue{
                offer(String) : Bool
                add(String) : Bool
                addAll(List<String>) : Bool
                poll() : String
                contains(String) : Bool
                isEmpty() : Bool
              }
          ]|
        else
          sec_asyncDirtyflag* := []
        end
      with
        if modulename-is-calconwrite then
          sec_hibernateTriggers* :=  section* |[
            section triggers
          
              function beforeTransactionCompletion(){
                updateDerivations();
                flush();
              }
          ]|
        else if modulename-is-eventuallyconsistent then
          sec_hibernateTriggers* :=  section* |[
            section triggers
              
              function afterTransactionCompletionCommitted(){
                flagDirtyAsync();
              }
          ]|
        else
          sec_hibernateTriggers* := []
        end end
    with
      if modulename-is-noui then
          result := application |[
            application x_moduleName
          
            imports lib/icedust/crud-ui
            imports lib/icedust/Expressions
        
            sec_modelDataUi*
          
            sec_cachesDirtyflag*
          
            sec_asyncDirtyflag*
          
            sec_hibernateTriggers*
          ]|
        else if modulename-is-newcrudui then
          result := application |[
            application x_moduleName
          
            imports lib/icedust/newcrud-ui
            imports lib/icedust/non-required-inputs
            imports lib/icedust/Expressions
        
            sec_modelDataUi*
          
            sec_cachesDirtyflag*
          
            sec_asyncDirtyflag*
          
            sec_hibernateTriggers*
          ]|          
        else
          result := module |[
            module x_moduleName
          
            imports lib/icedust/crud-ui
            imports lib/icedust/Expressions
        
            sec_modelDataUi*
          
            sec_cachesDirtyflag*
          
            sec_asyncDirtyflag*
          
            sec_hibernateTriggers*
          ]|
      end end

rules //crud
  
  entityname-to-webdsl-defs: x_entityName -> result
    with
      elem_nameString:= String(x_entityName);
      x_manageEntity := <name-manage>x_entityName;
      x_createEntity := <name-create>x_entityName;
      x_editEntity   := <name-edit>x_entityName;
      x_removeEntity := <name-remove>x_entityName;
      x_viewEntity   := <lcfirst>x_entityName;
      attributenames := <entityname-get-attributenames2>x_entityName;
      relations := <entityname-get-relationnames> x_entityName;
      relationsOnes := <filter(where(get-multiplicity; ?One()))> relations;
      attributenames-normal-default := <entityname-get-attributenames2-normal-default>x_entityName;
      numberOfAttributes := <length>attributenames;
      numberOfAttributesNormalDefault := <length>attributenames-normal-default;
      entity-fields := <map(attributename-to-webdsl)>attributenames;
      allNames := <conc> (attributenames, relationsOnes);
      createNames := <filter(attributename-is-normal-default)> allNames;
      elem_deriveRowsVarCreate := <map(attributename-to-webdsl-varcreate)> createNames;
      elem_deriveRowsInputCreate := <map(attributename-to-webdsl-inputedit)> createNames;
      elem_deriveRowsVarEdit := <map(attributename-to-webdsl-varedit)>attributenames-normal-default;
      elem_deriveRowsInputEdit := <map(attributename-to-webdsl-inputedit)>attributenames;
      elem_deriveRowsOutputView := <map(attributename-to-webdsl-outputview)>attributenames;
      
      if <?0> numberOfAttributesNormalDefault then
        x_createEntityBlock := ObjectCreation(x_entityName, [])
      else
        x_createEntityBlock :=
          ObjectCreation(x_entityName, <map(attributename-to-creation-property)> attributenames-normal-default)
      end;
      
      stat_assignEditEntity := <map(attributename-to-webdsl-assignedit)> attributenames-normal-default;
      def_relationsetters := <map(relationname-to-setter(|x_entityName))> relations;
      elem_editRelations := <map(relationname-to-editlink)> relations;
      elem_relationsOutputView := <map(relationname-to-output)> relations;
      stat_createDefaultWrap* :=
        <filter(where(_get-type; ?String()); attributename-is-default);
         map(create-wrap-default)> attributenames;
      attributenames-default-derivation := <entityname-get-attributenames2-default-derivation> x_entityName;
      partial_vars := <fmap(attributename-get-expr-tiersplit-vars)> attributenames-default-derivation;
      elem_hiddenvars* := <map(var-to-hidden-div)> partial_vars;
      
      ctime := "0";//<time>;
      x_jsExpressions := <double-quote> $[Expressions.js?[ctime]];
      x_jsLib := <double-quote> $[javascript-lib.js?[ctime]];
      x_jsDerivations := <double-quote> $[derivations.js?[ctime]]
    with
      if entityname-is-newcrudui then
        result := def* |[
          page x_manageEntity(){
            main()
            define body() {
              header{ elem_nameString }
              navigate x_createEntity() [class="ice-ent-create"] { "Create " }
              <br/>
              for(entity: x_entityName order by entity.name asc) {
                div[class="ice-ent"]{
                  div[class="ice-ent-name"]{
                    navigate x_viewEntity(entity) [] { output(entity.name) }
                  }
                  action("Delete", x_removeEntity(entity))
                }
              }
              action x_removeEntity(entity: x_entityName) {
                entity.delete();
              }
            }
          }
          
          page x_createEntity(){
            main()
            define body() {
              header{ "Create " elem_nameString } 
              elem_deriveRowsVarCreate
              div[class="ice-form"] {
                form {
                  elem_deriveRowsInputCreate
                  <br/>
                  action("Save", save())
                }
              }
              action save() {
                stat_createDefaultWrap*
                var temp := x_createEntityBlock;
                temp.save();
                return x_viewEntity(temp);
              }
            }
          }
          
          page x_viewEntity(temp: x_entityName){
            includeJS(x_jsExpressions)
            includeJS(x_jsLib)
            includeJS(x_jsDerivations)
            main()
            define body() {
              header{"Edit " output(temp.name)}
              elem_deriveRowsVarEdit
              div[class="ice-form"] {
                form {
                  elem_editRelations
                  elem_hiddenvars*
                  elem_deriveRowsInputEdit
                  <br/>
                  submit action {
                    stat_assignEditEntity
                    temp.save();
                  } { "Save" }
                }
              }
            }
          }

          def_relationsetters
        ]|
      else if entityname-is-calconread then
        result := [DeriveCrud(x_entityName)]
      else
        form-fields :=
          <concat(
            entityname-get-attributenames-normal-default,
            entityname-get-relationnames,
            entityname-get-rolenames,
            entityname-get-inversenames
          );map(attributename-to-webdsl)>x_entityName;
        elem_deriveEditRowsTemp := Derive("editRows", Var("temp"), form-fields);
        elem_deriveEditRowsArg  := Derive("editRows", Var("arg"),  form-fields);  
        result := def* |[
          define page x_createEntity(){
            //derive createPage from temp
            main()
            define body() {
              var temp := x_entityName{}
              header{"Create " output(temp.name) } 
              form { 
                <fieldset>
                  <legend>
                    output("Details")
                  </legend>
                  <table>
                    elem_deriveEditRowsTemp
                    // derive editRows from temp
                  </table>
                </fieldset>      
                action("Save", save())
              }
              action save() { 
                temp.save();
                return x_manageEntity();
              }
            }
          }
          define page x_viewEntity(arg : x_entityName){
            derive viewPage from arg
          }
          define page x_editEntity(arg : x_entityName){
            //derive editPage from arg
            main()
            define body() {
              header{"Edit " output(arg.name) } 
              form { 
                <fieldset>
                  <legend>
                    output("Details")
                  </legend>
                  <table>
                    elem_deriveEditRowsArg
                    // derive editRows from arg
                  </table>
                </fieldset>  
                action("Save", save())
              }
              action save() { 
                arg.save();
                return x_manageEntity();
              }
            }
          }
          define page x_manageEntity(){
            main()
            define body(){
              navigate(x_createEntity()){ "create" }
              <list>
                for(elem : x_entityName){
                  <li> 
                    output(elem)
                    " "
                    navigate(x_editEntity(elem)){ "edit" }
                    " "
                    form{action("remove",remove(elem))}
                  </li>
                }
              </list>
              action remove(arg : x_entityName){
                arg.delete();
              }
            }
          }
        ]|
      end end
  
  attributename-to-webdsl: x_name -> DeriveDefault(x_name)
  
  entityname-to-webdsl-elem: x_entityName -> result
    with
      x_manageName := $[manage[x_entityName]];
      $text := Text(x_entityName)
    with
      result := elem |[
        navbaritem{navigate x_manageName(){$text}}
      ]|

rules //crud rules
  
  var-to-hidden-div: Partial(name, expr) -> result
    with
      type := <name-to-type-string> expr;
      x_strname := <double-quote> name;
      x_strtype := <double-quote> type;
      x_getname := <name-get> name;
      result := elem |[
        <div
          data-partial-var="true"
          data-name=x_strname
          data-type=x_strtype
          style="display:none">
          output(temp.x_getname().toString())
        </div>
      ]|

  create-wrap-default : x_name -> result
  with
    result := stat |[
      if(x_name.trim() == "") {
        x_name := null;
      }
    ]|

  attributename-to-webdsl-varcreate : x_name -> result
  with
    x_type := <name-to-webdsl-srt(err)>x_name;
    result := def |[
      var x_name : x_type
    ]|
  
  booleantype-to-webdsl-inputtext : ZeroOrOne() -> result
  with
    result := "inputNonRequiredBool"
    
  booleantype-to-webdsl-inputtext : m -> result
  with
    result := "input"
    
  relationname-to-editlink : x_name -> result
  with
    entity := <attributename-get-entityname> x_name;
    x_namestr := String(<ucfirst>x_name);
    x_setname := $[set_[entity]_[x_name]];
    x_s := <double-quote> x_name;
    x_getname := <name-get> x_name;
    result := elem* |[
      <div class="ice-attr">
        <div class="ice-attr-name">
          "" x_namestr ":"
        </div>
        <div class="ice-rel-val">
          "" output(temp.x_getname())
        </div>
        <div class="ice-rel-edit">
          navigate x_setname(temp) [] { "Edit " }
        </div>
      </div>
    ]|
    
  relationname-to-output : x_name -> result
  with
    mult := <get-multiplicity> x_name;
    x_s := <double-quote> x_name;
    x_getname := <name-get> x_name;
    if <?ZeroOrMore()> mult then // *
      result := elem* |[
        <b>x_s ": "</b> <br/>
        for(s in temp.x_getname()) {
          output(s.name) <br/>
        }
      ]|
    else // 1 ?
      result := elem* |[
        x_s ": " output(temp.x_getname().name) <br/>
      ]|
    end  
  
  relationname-to-setter(|x_entityName) : x_name -> result
  with
    mult := <get-multiplicity> x_name;
    x_setname := $[set_[x_entityName]_[x_name]];
    x_stringifiedname := <double-quote> x_name;
    x_getname := <name-get> x_name;
    x_editEntity := <name-edit> x_entityName;
    x_viewEntity   := <lcfirst>x_entityName;
    x_inverseName := <name-get-inversename> x_name;
    x_entname := <attributename-get-entityname>x_inverseName;
    if <?One()> mult then // 1
      result := def |[
        page x_setname(ent: x_entityName) {
          main()
          define body() {
            header{ "Edit " output(ent.name) " " x_stringifiedname }
            <div class="ice-form">
              <div class="ice-attr">
                <div class="ice-attr-name">
                  "" x_stringifiedname ":"
                </div>
                <div class="ice-rel-val">
                  "" output(ent.x_getname())
                </div>
              </div>
            </div>
            <div class="ice-form2">
              for(s: x_entname order by s.name asc) {
                if(ent.x_getname() != s) {
                  div[class="ice-ent"]{
                    div[class="ice-ent-name"]{
                      output(s)
                    }
                    submit action {
                      ent.x_name := s;
                      ent.save();
                    } { "Set" }
                  }
                }
              }
            </div>
          }
        }
      ]|
    else
      if <?ZeroOrOne()> mult then // ?
        result := def |[
          page x_setname(ent: x_entityName) {
            main()
            define body() {
              header{ "Edit " output(ent.name) " " x_stringifiedname }
              <div class="ice-form">
                <div class="ice-attr">
                  <div class="ice-attr-name">
                    "" x_stringifiedname ":"
                  </div>
                  <div class="ice-rel-val">
                    "" output(ent.x_getname())
                  </div>
                  if(ent.x_getname() != null){
                    <div class="ice-rel-edit">
                      submit action {
                        ent.x_name := null;
                        ent.save();
                      } { "Remove" }
                    </div>
                  }
                </div>
              </div>
              <div class="ice-form2">
                for(s: x_entname order by s.name asc) {
                  if(ent.x_getname() != s) {
                    div[class="ice-ent"]{
                      div[class="ice-ent-name"]{
                        output(s)
                      }
                      submit action {
                        ent.x_name := s;
                        ent.save();
                      } { "Set" }
                    }
                  }
                }
              </div>
            }
          }
        ]|
      else // *
        result := def |[
          page x_setname(ent: x_entityName) {
            main()
            define body() {
              header{ "Edit " output(ent.name) " " x_stringifiedname }
              <div class="ice-form">
                <div class="ice-attr">
                  <div class="ice-attr-name">
                    "" x_stringifiedname ":"
                  </div>
                  <div class="ice-rel-vals">
                    for(s in ent.x_getname()) {
                      <div class="ice-rel-val">
                        "" output(s)
                      </div>
                      <div class="ice-rel-edit">
                        submit action {
                          ent.x_name.remove(s);
                          ent.save();
                        } { "Remove" }
                      </div>
                      <br/>
                    }
                  </div>
                </div>
              </div>
              <div class="ice-form2">
                for(s: x_entname order by s.name asc) {
                  if(ent.x_getname().indexOf(s) == -1) {
                    div[class="ice-ent"]{
                      div[class="ice-ent-name"]{
                        output(s)
                      }
                      submit action {
                        ent.x_name.add(s);
                        ent.save();
                      } { "Add" }
                    }
                  }
                }
              </div>
            }
          }
        ]|
      end
    end
  
  attributetype-to-webdsl-inputtext(|x_name) : type -> result
  with
    result := "input"
  
  attributename-to-webdsl-inputcreate : x_name -> result
  with
    x_qname := <double-quote> x_name;
    elem_input := <name-to-webdsl-input> x_name;
    result := elem* |[ "" x_qname ": " elem_input <br/> ]|
  
  name-to-webdsl-input : x_name -> result
  with
    if <_get-type;Boolean()> x_name then
      if <get-multiplicity;ZeroOrOne()> x_name then
        result := elem |[ inputNonRequiredBool(x_name) ]|
      else
        result := elem |[ input(x_name) ]|
      end
    else
      result := elem |[ input(x_name) ]|
    end
  
  name-to-type-string : x_name -> result
  with
    type := <_get-type> x_name;
    if <Boolean()> type then
      if <get-multiplicity;One()> x_name then
        result := "Boolean"
      else
        result := "Boolean?"
      end
    else
      if <Float()> type then
        if <get-multiplicity;One()> x_name then
          result := "Float"
        else
          result := "Float?"
        end
      else
        if <Int()> type then
          if <get-multiplicity;One()> x_name then
            result := "Int"
          else
            result := "Int?"
          end
        else
          if <String()> type then
            if <get-multiplicity;One()> x_name then
              result := "String"
            else
              result := "String?"
            end
          else
            if <Datetime()> type then
              if <get-multiplicity;One()> x_name then
                result := "Datetime"
              else
                result := "Datetime?"
              end
            else
              result := "UnimplementedType"
            end
          end
        end
      end
    end
    
  extract-flow : DataflowPath(x, Ref(y)) ->
    $[[<attributename-get-entityname> y]_[y]]
  extract-flow : DataflowPath(x, y) -> ""
  
  add-space : s -> <conc-strings> (s, " ")
  
  attributename-to-webdsl-inputedit : x_name -> result
  with
    x_namestr := String(<ucfirst>x_name);
    entityName := <attributename-get-entityname> x_name;
    x_derivedname := $["[entityName]_[x_name]"];
    x_typestr := <name-to-type-string; double-quote> x_name;
    x_input := <name-to-webdsl-input> x_name;
    flows := <name-get-flowsto-paths> x_name;
    flows-extracted := <map(extract-flow)> flows;
    x_flows := <map(add-space); concat-strings; double-quote> flows-extracted;
    if <attributename-is-derivation>x_name then
      x_output := <attributename-to-webdsl-output> x_name;
      result := elem* |[
        <div class="ice-attr">
          <div class="ice-attr-name">
            "" x_namestr ":"
          </div>
          <div class="ice-attr-val ice-attr-output">
            <div
              data-name = x_derivedname
              data-type = x_typestr
              data-updates = x_flows>
              <div class="output">
                "" x_output
              </div>
              <div class="error-msg"></div>
            </div>
          </div>
        </div>
      ]|
    else
    if <attributename-is-default> x_name then
        result := elem* |[
          <div class="ice-attr">
            <div class="ice-attr-name">
              "" x_namestr ":"
            </div>
            <div class="ice-attr-val ice-attr-input-output">
              <div
                data-name = x_derivedname
                data-type = x_typestr
                data-updates = x_flows
                data-default = "true">
                "" x_input
                <div class="error-msg"></div>
                <div class="default-output"></div>
              </div>
            </div>
          </div>
        ]|
      else
        result := elem* |[
          <div class="ice-attr">
            <div class="ice-attr-name"> 
              "" x_namestr ":"
            </div>
            <div class="ice-attr-val ice-attr-input">
              <div
                data-name = x_derivedname
                data-type = x_typestr
                data-updates = x_flows>
                "" x_input
                <div class="error-msg"></div>
                <div class="default-output"></div>
              </div>
            </div>
          </div>
        ]|
      end
    end
  
  attributename-to-creation-property : x_name -> ObjectPropertyAssignment(x_name, Var(x_name))

  attributename-to-webdsl-assignedit : x_name -> result
  with
    if <attributename-is-default>x_name then
      if <_get-type;String()>x_name then
        result := stat |[
          if(x_name.trim() != "") {
            temp.x_name := x_name;
          } else {
            temp.x_name := null;
          }
        ]|
      else
        result := stat |[
          if(x_name != null) {
              temp.x_name := x_name;
          } else {
              temp.x_name := null;
          }
        ]|
      end
    else
      result := stat |[temp.x_name := x_name;]|
    end
    
  attributename-to-webdsl-varedit: x_name -> result
  with
    ux_name := <ucfirst>x_name;
    if <attributename-is-default>x_name then
      x_nameRightHand := $[temp.[x_name]];
      result := def |[
        var x_name := x_nameRightHand
      ]|
    else
      x_nameRightHand := $[temp.get[ux_name]()];
      result := def |[
        var x_name := x_nameRightHand
      ]|
    end
    
    attributename-to-webdsl-output: x_name ->  result
  with
    x_getname := <name-get> x_name;
    if <_get-type;Datetime()>x_name then
      result := elem |[output(temp.x_name)]|
    else
      result := elem |[output(temp.x_getname())]|
    end
    
  attributename-to-webdsl-outputview: x_name ->  result
  with
    x_qname := <double-quote> x_name;
    if <_get-type;Datetime()>x_name then
      result := elem* |["" x_qname ": " output(temp.x_name) <br/>]|
    else
      x_getname := <name-get> x_name;
      result := elem* |["" x_qname ": " output(temp.x_getname()) <br/>]|
    end
    
rules // derivations
  
  attributename-to-webdsl-def: x_attributeName -> result
    with
      x_entityName := <attributename-get-entityname>x_attributeName;
      x_dirty      := <attributename-entityname-dirty>x_attributeName
    with
      result := def |[
        request var x_dirty := Set<x_entityName>()
      ]|
      
  attributename-to-webdsl-stat: x_attributeName -> result
    with
      x_entityName                := <attributename-get-entityname>x_attributeName;
      x_flagAttributeDirtyAsync   := <name-flagdirtyasync>x_attributeName
    with
      result := stat |[
        x_entityName.x_flagAttributeDirtyAsync();
      ]|
      
  attributename-to-webdsl-native: x_attributeName -> result
    with
      x_attributeGetQueue := <attributename-entityname-getqueue>x_attributeName
    with
      result := native |[
        static x_attributeGetQueue() : Queue
      ]|

rules
  
  cache-modulename-to-webdsl-stms: x_moduleName -> result
    with
      namess := <modulename-get-attributenames-topo-default-derivation>x_moduleName;
      stat_updat* := <fmap(cache-attributenames-to-webdsl-stms)>namess
    with
      if (modulename-is-calconwrite<+modulename-is-eventuallyconsistent) then
        result := stat* |[
          var notEmpty : Bool;
          stat_updat*
        ]|
      else
        result := []
      end
      
  cache-attributenames-to-webdsl-stms: attributeNames -> result
    with
      stat_updat* := <map(cache-attributename-to-webdsl-stm-update)>attributeNames;
      stat_empty* := <map(cache-attributename-to-webdsl-stm-empty)>attributeNames
    with
      result := stat* |[
        notEmpty := true;
        while(notEmpty){
          stat_updat*
          notEmpty := false;
          stat_empty*
        }
      ]|
      
  cache-attributename-to-webdsl-stm-update: x_attributeName -> result
    with
      x_entityName              := <attributename-get-entityname>x_attributeName;
      x_updateAllAttributeCache := <name-updateallcache>x_attributeName
    with
      result := stat |[
        x_entityName.x_updateAllAttributeCache();
      ]|
      
  cache-attributename-to-webdsl-stm-empty: x_attributeName -> result
    with
      x_entityName              := <attributename-get-entityname>x_attributeName;
      x_hasDirty                := <name-hasdirty>x_attributeName
    with
      result := stat |[
        notEmpty := notEmpty || x_entityName.x_hasDirty();
      ]|

rules
  
  cache-async-modulename-to-webdsl-stms: x_moduleName -> result
    with
      namess := <modulename-get-attributenames-topo-default-derivation>x_moduleName;
      stat_updat* := <fmap(cache-async-attributenames-to-webdsl-stms)>namess
    with
      if (modulename-is-calconwrite<+modulename-is-eventuallyconsistent) then
        result := stat* |[
          var notEmpty : Bool;
          stat_updat*
        ]|
      else
        result := []
      end
      
  cache-async-attributenames-to-webdsl-stms: attributeNames -> result
    with
      stat_updat* := <map(cache-async-attributename-to-webdsl-stm-update)>attributeNames;
      stat_empty* := <map(cache-async-attributename-to-webdsl-stm-empty)>attributeNames
    with
      result := stat* |[
        notEmpty := true;
        while(notEmpty){
          stat_updat*
          notEmpty := false;
          stat_empty*
        }
      ]|
      
  cache-async-attributename-to-webdsl-stm-update: x_attributeName -> result
    with
      x_entityName                   := <attributename-get-entityname>x_attributeName;
      x_updateAllAttributeCacheAsync := <name-updateallcacheasync>x_attributeName
    with
      result := stat |[
        x_entityName.x_updateAllAttributeCacheAsync();
      ]|
      
  cache-async-attributename-to-webdsl-stm-empty: x_attributeName -> result
    with
      x_entityName              := <attributename-get-entityname>x_attributeName;
      x_hasDirtyAsync           := <name-hasdirtyasync>x_attributeName
    with
      result := stat |[
        notEmpty := notEmpty || x_entityName.x_hasDirtyAsync();
      ]|
