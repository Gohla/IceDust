module generating/webdsl/module

imports // constructors

  webdsl/constructors
  webdsl/WebDSL
  desugaring/constructors
  signatures/Types-sig
  analysis2/path

imports // functions
  
  generating/_ir/model 
  generating/webdsl/model
  generating/webdsl/data
  generating/webdsl/types
  api/model-names-api
  api/module-api
  api/module-names-api
  lib/lists-tuples
  lib/string

rules // module

  modulename-to-webdsl-application(err): x_moduleName -> result
    where
      is-modulename
    with
      def_model*     := <modulename-get-entitynames; map(model-entityname-to-webdsl-def(err))>x_moduleName;
      def_crud*      := <modulename-get-entitynames;fmap(entityname-to-webdsl-defs)>x_moduleName;
      elem_menu*     := <modulename-get-entitynames; map(entityname-to-webdsl-elem)>x_moduleName;
      stat_initdata* := <data-modulename-to-webdsl-stms(err)>x_moduleName
    with
      if (modulename-is-calconwrite<+modulename-is-eventuallyconsistent) then
        def_dirtyReqVar* := <modulename-get-attributenames-default-derivation;map(attributename-to-webdsl-def)>x_moduleName;
        stat_cach*       := <cache-modulename-to-webdsl-stms>x_moduleName
      end
      with
        if modulename-is-eventuallyconsistent then
          stat_flagasync*    := <modulename-get-attributenames-default-derivation;map(attributename-to-webdsl-stat)>x_moduleName;
          native1*           := <modulename-get-attributenames-default-derivation;map(attributename-to-webdsl-native)>x_moduleName;
          stat_cachAsync*    := <cache-async-modulename-to-webdsl-stms>x_moduleName
        end
      with
        sec_modelDataUi* := section* |[
          section data
            
            init {
              stat_initdata*
            }
          
          section model
          
            def_model*
          
          section ui
          
            define applicationmenu() {
              elem_menu*
            }
            
            def_crud*
        ]|
      with
        if modulename-is-calconwrite  then  
          sec_cachesDirtyflag* := section* |[
            section caches and dirty flags
            
              def_dirtyReqVar*
              
              function updateDerivations(){
                stat_cach*
              }
          ]|
        else if modulename-is-eventuallyconsistent then  
          sec_cachesDirtyflag* := section* |[
            section caches and dirty flags
            
              def_dirtyReqVar*
          ]|
        else
          sec_cachesDirtyflag* := []
        end end
      with
        if modulename-is-eventuallyconsistent then
          sec_asyncDirtyflag* :=  section* |[
            section async dirty flags
              
              function flagDirtyAsync(){
                stat_flagasync*
              }
              
              function updateDerivationsAsync(){
                stat_cachAsync*
              }
              
              invoke updateDerivationsAsync() every 1 milliseconds
              
              native class derivations.DirtyCollections as DirtyCollections {
                native1*
              }
              
              native class java.util.Queue as Queue{
                offer(String) : Bool
                add(String) : Bool
                addAll(List<String>) : Bool
                poll() : String
                contains(String) : Bool
                isEmpty() : Bool
              }
          ]|
        else
          sec_asyncDirtyflag* := []
        end
      with
        if modulename-is-calconwrite then
          sec_hibernateTriggers* :=  section* |[
            section triggers
          
              function beforeTransactionCompletion(){
                updateDerivations();
                flush();
              }
          ]|
        else if modulename-is-eventuallyconsistent then
          sec_hibernateTriggers* :=  section* |[
            section triggers
              
              function afterTransactionCompletionCommitted(){
                flagDirtyAsync();
              }
          ]|
        else
          sec_hibernateTriggers* := []
        end end
    with
      if modulename-is-noui then
          result := application |[
            application x_moduleName
          
            imports lib/icedust/crud-ui
            imports lib/icedust/Expressions
        
            sec_modelDataUi*
          
            sec_cachesDirtyflag*
          
            sec_asyncDirtyflag*
          
            sec_hibernateTriggers*
          ]|
        else if modulename-is-newcrudui then
          result := application |[
            application x_moduleName
          
            imports lib/icedust/newcrud-ui
        imports lib/icedust/non-required-inputs
            imports lib/icedust/Expressions
        
            sec_modelDataUi*
          
            sec_cachesDirtyflag*
          
            sec_asyncDirtyflag*
          
            sec_hibernateTriggers*
          ]|          
        else
          result := module |[
            module x_moduleName
          
            imports lib/icedust/crud-ui
            imports lib/icedust/Expressions
        
            sec_modelDataUi*
          
            sec_cachesDirtyflag*
          
            sec_asyncDirtyflag*
          
            sec_hibernateTriggers*
          ]|
      end end

rules //crud
  
  entityname-to-webdsl-defs: x_entityName -> result
    with
      x_manageEntity := <name-manage>x_entityName;
      x_createEntity := <name-create>x_entityName;
      x_editEntity   := <name-edit>x_entityName;
      x_removeEntity := <name-remove>x_entityName;
      x_viewEntity   := <lcfirst>x_entityName;
      attributenames := <entityname-get-attributenames>x_entityName;
      relations := <entityname-get-relationnames> x_entityName;
      relationsOnes := <filter(where(get-multiplicity; ?One()))> relations;
      attributenames-normal-default := <entityname-get-attributenames-normal-default>x_entityName;
      numberOfAttributes := <length>attributenames;
      numberOfAttributesNormalDefault := <length>attributenames-normal-default;
      entity-fields := <map(attributename-to-webdsl)>attributenames;
      allNames := <conc> (attributenames, relationsOnes);
      createNames := <filter(attributename-is-normal-default)> allNames;
      elem_deriveRowsVarCreate := <map(attributename-to-webdsl-varcreate)> createNames;
      elem_deriveRowsInputCreate := <map(attributename-to-webdsl-inputcreate)> createNames;
      //elem_deriveRowsTest := <take(|<dec>numberOfAttributes);map(attributename-to-webdsl-assigncreate)>attributenames;
      //x_testy := elem_deriveRowsTest;
      //x_testyr := <last;attributename-to-webdsl-assigncreatelast>attributenames;
      elem_deriveRowsVarEdit := <map(attributename-to-webdsl-varedit)>attributenames-normal-default;
      elem_deriveRowsInputEdit := <map(attributename-to-webdsl-inputedit)>attributenames;
      elem_deriveRowsOutputView := <map(attributename-to-webdsl-outputview)>attributenames;
      x_testy := <concat> [<take(|<dec>numberOfAttributesNormalDefault);map(attributename-to-webdsl-assigncreate)>attributenames-normal-default,[<last;attributename-to-webdsl-assigncreatelast>attributenames-normal-default]];
      stat_assignEditEntity := <map(attributename-to-webdsl-assignedit)> attributenames-normal-default;
      elem_deriveEditRowsTemp := Derive("editRows", Var("temp"), attributenames);
      elem_deriveEditRowsArg  := Derive("editRows", Var("arg"),  attributenames);
      def_relationsetters := <map(relationname-to-setter(|x_entityName))> relations;
      elem_editRelations := <map(relationname-to-editlink)> relations;
      elem_a := elem_editRelations;
      elem_relationsOutputView := <map(relationname-to-output)> relations;
      stat_createDefaultWrap* :=
        <filter(where(_get-type; ?String()); attributename-is-default);
         map(create-wrap-default)> attributenames
    with
      if entityname-is-calconread then
        result := def* |[
          page x_manageEntity(){
            main()
            define body() {
          navigate x_createEntity() [] { "Create" }
          <br/>
          for(entity: x_entityName) {
            output(entity.name)
            navigate x_viewEntity(entity) [] { "View" } " "
            navigate x_editEntity(entity) [] { "Edit" } " "
            action("Remove", x_removeEntity(entity))
            <br/>
          }
        
          action x_removeEntity(entity: x_entityName) {
            entity.delete();
          }
        }
          }
          page x_createEntity(){
            main()
            define body() {
              header{"Create"} 
              elem_deriveRowsVarCreate
        form {
          elem_deriveRowsInputCreate
          action("Save", save())
          // print form fields
              
        }
        action save() {
          stat_createDefaultWrap*
            var temp := x_entityName {
            x_testy
            };
          temp.save();
        }
        navigate x_manageEntity() [] { "Back" }
      }
          }
          page x_viewEntity(temp: x_entityName){
            main()
            define body() {
              header{"View"}
              elem_deriveRowsOutputView
              <hr/>
              elem_relationsOutputView
              navigate x_manageEntity() [] { "Back" }
            }
          }
          page x_editEntity(temp: x_entityName){
            includeJS("Expressions.js")
            includeJS("javascript-lib.js")
            includeJS("derivations.js")
            main()
            define body() {
              header{"Edit"}
              elem_deriveRowsVarEdit
              form {
                elem_deriveRowsInputEdit
                submit action {
                  stat_assignEditEntity
                  temp.save();
                } { "Save" }
              }
              <hr/>
              elem_editRelations
              navigate x_manageEntity() [] { "Back" }
            }
          }
          
          def_relationsetters
        ]|
      else
        result := def* |[
          define page x_createEntity(){
            //derive createPage from temp
            main()
            define body() {
              var temp := x_entityName{}
              header{"Create " output(temp.name) } 
              form { 
                <fieldset>
                  <legend>
                    output("Details")
                  </legend>
                  <table>
                    elem_deriveEditRowsTemp
                    // derive editRows from temp
                  </table>
                </fieldset>      
                action("Save", save())
              }
              action save() { 
                temp.save();
                return x_manageEntity();
              }
            }
          }
          define page x_viewEntity(arg : x_entityName){
            derive viewPage from arg
          }
          define page x_editEntity(arg : x_entityName){
            //derive editPage from arg
            main()
            define body() {
              header{"Edit " output(arg.name) } 
              form { 
                <fieldset>
                  <legend>
                    output("Details")
                  </legend>
                  <table>
                    elem_deriveEditRowsArg
                    // derive editRows from arg
                  </table>
                </fieldset>  
                action("Save", save())
              }
              action save() { 
                arg.save();
                return x_manageEntity();
              }
            }
          }
          define page x_manageEntity(){
            main()
            define body(){
              navigate(x_createEntity()){ "create" }
              <list>
                for(elem : x_entityName){
                  <li> 
                    output(elem)
                    " "
                    navigate(x_editEntity(elem)){ "edit" }
                    " "
                    form{action("remove",remove(elem))}
                  </li>
                }
              </list>
              action remove(arg : x_entityName){
                arg.delete();
              }
            }
          }
        ]|
      end
  
  attributename-to-webdsl: x_name -> DeriveDefault(x_name)
  
  entityname-to-webdsl-elem: x_entityName -> result
    with
      x_manageName := $[manage[x_entityName]];
      $text := Text(x_entityName)
    with
      result := elem |[
        navbaritem{navigate x_manageName(){$text}}
      ]|

rules //crud rules
  create-wrap-default : x_name -> result
  with
    result := stat |[
      if(x_name.trim() == "") {
        x_name := null;
      }
    ]|

  attributename-to-webdsl-varcreate : x_name -> result
  with
    x_type := <name-to-webdsl-srt(err)>x_name;
    result := def |[
      var x_name : x_type
    ]|
  
  booleantype-to-webdsl-inputtext : ZeroOrOne() -> result
  with
    result := "inputNonRequiredBool"
    
  booleantype-to-webdsl-inputtext : m -> result
  with
    result := "input"
    
  relationname-to-editlink : x_name -> result
  with
    x_setname := $[set_[x_name]];
    x_s := $["[x_name]"];
    x_getname := <name-get> x_name;
    result := elem* |[
      x_s ": "
      output(temp.x_getname()) " "
      navigate x_setname(temp) [] { "Set " x_s } <br/>
    ]|
    
  relationname-to-output : x_name -> result
  with
    mult := <get-multiplicity> x_name;
    x_s := $["[x_name]"];
    x_getname := <name-get> x_name;
    if <?ZeroOrMore()> mult then // *
      result := elem* |[
        <b>x_s ": "</b> <br/>
        for(s in temp.x_getname()) {
          output(s.name) <br/>
        }
      ]|
    else // 1 ?
      result := elem* |[
        x_s ": " output(temp.x_getname().name) <br/>
      ]|
    end  
  
  relationname-to-setter(|x_entityName) : x_name -> result
  with
    mult := <get-multiplicity> x_name;
    x_setname := $[set_[x_name]];
    x_stringifiedname := $["[x_name]"];
    x_getname := <name-get> x_name;
    x_editEntity := <name-edit> x_entityName;
    x_inverseName := <name-get-inversename> x_name;
    x_entname := <attributename-get-entityname>x_inverseName;
    if <?One()> mult then // 1
      result := def |[
        page x_setname(ent: x_entityName) {
          main()
          define body() {
            "Set " x_stringifiedname " for: " output(ent.name) <br/>
            "Current " x_stringifiedname ": " output(ent.x_getname().name) <br/>
            <hr/>
            for(f: x_entname) {
              output(f.name)
              submit action {
                ent.x_name := f;
                ent.save();
              } { "Set" }
              <br/>
            }
            navigate x_editEntity(ent) [] { "Back" }
          }
        }
      ]|
    else
      if <?ZeroOrOne()> mult then // ?
        result := def |[
          page x_setname(ent: x_entityName) {
            main()
            define body() {
              "Set " x_stringifiedname " for: " output(ent.name) <br/>
              "Current " x_stringifiedname ": " output(ent.x_getname().name) <br/>
              <hr/>
              "null"
              submit action {
                ent.x_name := null;
                ent.save();  
              } { "Set" }
              <br/>
              for(f: x_entname) {
                output(f.name)
                submit action {
                  ent.x_name := f;
                  ent.save();
                } { "Set" }
                <br/>
              }
              navigate x_editEntity(ent) [] { "Back" }
            }
          }
        ]|
      else // *
        result := def |[
          page x_setname(ent: x_entityName) {
            main()
            define body() {
              "Set " x_stringifiedname " for: " output(ent.name) <br/>
              "Current entities in " x_stringifiedname ": " <br/>
              for(s in ent.x_getname()) {
                output(s.name)
                submit action {
                  ent.x_name.remove(s);
                  ent.save();
                } { "Remove" }
                <br/>  
              }
              "Add: " <br/>
              for(s: x_entname) {
                if(ent.x_getname().indexOf(s) == -1) {
                  output(s.name)
                  submit action {
                    ent.x_name.add(s);
                    ent.save();
                  } { "Add" }
                  <br/>
                }
              }
              navigate x_editEntity(ent) [] { "Back" }
            }
          }
        ]|
      end
    end
  
  //attributetype-to-webdsl-inputtext(|x_name) : Boolean() -> result
  //with
  //  result := <get-multiplicity;booleantype-to-webdsl-inputtext> x_name  
  
  attributetype-to-webdsl-inputtext(|x_name) : type -> result
  with
    result := "input"
  
  attributename-to-webdsl-inputcreate : x_name -> result
  with
  	x_qname := <double-quote> x_name;
    elem_input := <name-to-webdsl-input> x_name;
    result := elem* |[ "" x_qname ": " elem_input ]|
  
  name-to-webdsl-input : x_name -> result
  with
    if <_get-type;Boolean()> x_name then
      if <get-multiplicity;ZeroOrOne()> x_name then
        result := elem |[ inputNonRequiredBool(x_name) ]|
      else
        result := elem |[ input(x_name) ]|
      end
    else
      result := elem |[ input(x_name) ]|
    end
    
  extract-flow : DataflowPath(x, Ref(y)) -> y
  
  add-space : s -> <conc-strings> (s, " ")
  
  name-to-type-string : x_name -> result
  with
    type := <_get-type> x_name;
    if <Boolean()> type then
      if <get-multiplicity;One()> x_name then
        result := "Boolean"
      else
        result := "Boolean?"
      end
    else
      if <Float()> type then
        if <get-multiplicity;One()> x_name then
          result := "Float"
        else
          result := "Float?"
        end
      else
        if <Int()> type then
          if <get-multiplicity;One()> x_name then
            result := "Int"
          else
            result := "Int?"
          end
        else
          if <String()> type then
            if <get-multiplicity;One()> x_name then
              result := "String"
            else
              result := "String?"
            end
          else
            if <Datetime()> type then
              if <get-multiplicity;One()> x_name then
                result := "Datetime"
              else
                result := "Datetime?"
              end
            else
              result := "UnimplementedType"
            end
          end
        end
      end
    end
  
  attributename-to-webdsl-inputedit : x_name -> result
  with
    x_namestr := String(x_name);
    x_typestr := <name-to-type-string; double-quote> x_name;
    x_input := <name-to-webdsl-input> x_name;
    flows := <name-get-flowsto-paths> x_name;
    flowstr := <map(extract-flow)> flows;
    x_flows := <map(add-space); concat-strings; double-quote> flowstr;
    if <attributename-is-derivation>x_name then
      x_output := <attributename-to-webdsl-output> x_name;
      result := elem* |[
        "" x_namestr ": "
      <div
        data-name = x_namestr
        data-type = x_typestr
        data-updates = x_flows>
          <div class="output">
          "" x_output
        </div>
          <div class="error-msg" style="color: red"></div>
      </div>
      <br/> 
      ]|
    else
    if <attributename-is-default> x_name then
        result := elem* |[
          "" x_namestr ": "
          <div
            data-name = x_namestr
            data-type = x_typestr
            data-updates = x_flows
            data-default = "true">
            "" x_input
            <div class="error-msg" style="color: red"></div>
          <div class="default-output"></div>
          </div>
          <br/>
        ]|
      else
        result := elem* |[
          "" x_namestr ": "
          <div
            data-name = x_namestr
            data-type = x_typestr
            data-updates = x_flows>
            "" x_input
            <div class="error-msg" style="color: red"></div>
          <div class="default-output"></div>
          </div>
          <br/>
        ]|
      end
    end
  
  attributename-to-webdsl-assigncreate: x_name -> result
  with
    result := $[[x_name] := [x_name],] 

  attributename-to-webdsl-assigncreatelast: x_name -> result
  with
    result := $[[x_name] := [x_name]] 

  attributename-to-webdsl-assignedit: x_name -> result
  with
    if <attributename-is-default>x_name then
      if <_get-type;String()>x_name then
        result := stat |[
          if(x_name.trim() != "") {
            temp.x_name := x_name;
          } else {
            temp.x_name := null;
          }
        ]|
      else
        result := stat |[
          if(x_name != null) {
              temp.x_name := x_name;
          } else {
              temp.x_name := null;
          }
        ]|
      end
    else
      result := stat |[temp.x_name := x_name;]|
    end
    
  attributename-to-webdsl-varedit: x_name -> result
  with
    ux_name := <ucfirst>x_name;
    if <attributename-is-default>x_name then
      x_nameRightHand := $[temp.[x_name]];
      result := def |[
        var x_name := x_nameRightHand
      ]|
    else
      x_nameRightHand := $[temp.get[ux_name]()];
      result := def |[
        var x_name := x_nameRightHand
      ]|
    end
    
    attributename-to-webdsl-output: x_name ->  result
  with
    x_getname := <name-get> x_name;
    if <_get-type;Datetime()>x_name then
      result := elem |[output(temp.x_name)]|
    else
      result := elem |[output(temp.x_getname())]|
    end
    
  attributename-to-webdsl-outputview: x_name ->  result
  with
    x_qname := <double-quote> x_name;
    if <_get-type;Datetime()>x_name then
      result := elem* |["" x_qname ": " output(temp.x_name) <br>]|
    else
      x_getname := <name-get> x_name;
      result := elem* |["" x_qname ": " output(temp.x_getname()) <br>]|
    end
    
rules // derivations
  
  attributename-to-webdsl-def: x_attributeName -> result
    with
      x_entityName := <attributename-get-entityname>x_attributeName;
      x_dirty      := <attributename-entityname-dirty>x_attributeName
    with
      result := def |[
        request var x_dirty := Set<x_entityName>()
      ]|
      
  attributename-to-webdsl-stat: x_attributeName -> result
    with
      x_entityName                := <attributename-get-entityname>x_attributeName;
      x_flagAttributeDirtyAsync   := <name-flagdirtyasync>x_attributeName
    with
      result := stat |[
        x_entityName.x_flagAttributeDirtyAsync();
      ]|
      
  attributename-to-webdsl-native: x_attributeName -> result
    with
      x_attributeGetQueue := <attributename-entityname-getqueue>x_attributeName
    with
      result := native |[
        static x_attributeGetQueue() : Queue
      ]|

rules
  
  cache-modulename-to-webdsl-stms: x_moduleName -> result
    with
      namess := <modulename-get-attributenames-topo-default-derivation>x_moduleName;
      stat_updat* := <fmap(cache-attributenames-to-webdsl-stms)>namess
    with
      if (modulename-is-calconwrite<+modulename-is-eventuallyconsistent) then
        result := stat* |[
          var notEmpty : Bool;
          stat_updat*
        ]|
      else
        result := []
      end
      
  cache-attributenames-to-webdsl-stms: attributeNames -> result
    with
      stat_updat* := <map(cache-attributename-to-webdsl-stm-update)>attributeNames;
      stat_empty* := <map(cache-attributename-to-webdsl-stm-empty)>attributeNames
    with
      result := stat* |[
        notEmpty := true;
        while(notEmpty){
          stat_updat*
          notEmpty := false;
          stat_empty*
        }
      ]|
      
  cache-attributename-to-webdsl-stm-update: x_attributeName -> result
    with
      x_entityName              := <attributename-get-entityname>x_attributeName;
      x_updateAllAttributeCache := <name-updateallcache>x_attributeName
    with
      result := stat |[
        x_entityName.x_updateAllAttributeCache();
      ]|
      
  cache-attributename-to-webdsl-stm-empty: x_attributeName -> result
    with
      x_entityName              := <attributename-get-entityname>x_attributeName;
      x_hasDirty                := <name-hasdirty>x_attributeName
    with
      result := stat |[
        notEmpty := notEmpty || x_entityName.x_hasDirty();
      ]|

rules
  
  cache-async-modulename-to-webdsl-stms: x_moduleName -> result
    with
      namess := <modulename-get-attributenames-topo-default-derivation>x_moduleName;
      stat_updat* := <fmap(cache-async-attributenames-to-webdsl-stms)>namess
    with
      if (modulename-is-calconwrite<+modulename-is-eventuallyconsistent) then
        result := stat* |[
          var notEmpty : Bool;
          stat_updat*
        ]|
      else
        result := []
      end
      
  cache-async-attributenames-to-webdsl-stms: attributeNames -> result
    with
      stat_updat* := <map(cache-async-attributename-to-webdsl-stm-update)>attributeNames;
      stat_empty* := <map(cache-async-attributename-to-webdsl-stm-empty)>attributeNames
    with
      result := stat* |[
        notEmpty := true;
        while(notEmpty){
          stat_updat*
          notEmpty := false;
          stat_empty*
        }
      ]|
      
  cache-async-attributename-to-webdsl-stm-update: x_attributeName -> result
    with
      x_entityName                   := <attributename-get-entityname>x_attributeName;
      x_updateAllAttributeCacheAsync := <name-updateallcacheasync>x_attributeName
    with
      result := stat |[
        x_entityName.x_updateAllAttributeCacheAsync();
      ]|
      
  cache-async-attributename-to-webdsl-stm-empty: x_attributeName -> result
    with
      x_entityName              := <attributename-get-entityname>x_attributeName;
      x_hasDirtyAsync           := <name-hasdirtyasync>x_attributeName
    with
      result := stat |[
        notEmpty := notEmpty || x_entityName.x_hasDirtyAsync();
      ]|
