module generating/webdsl/partial-expressions

imports // constructors

  webdsl/constructors
  webdsl/WebDSL
  signatures/Data-sig
  signatures/Expressions-sig  
  desugaring/constructors

imports // functions

  api/_runtime  
  api/module-names-api
  generating/_ir/expressions
  generating/webdsl/model
  generating/webdsl/data
  generating/webdsl/types
  names/naming/names
  lib/new-name
  lib/traverse

signature
  constructors
    NoRelation: Exp -> Exp
    Partial: STRING * Exp -> Exp

rules
  expr-is-partial = ?Partial(_,_)
  
  expr-is-norelation = ?NoRelation(_)
  
  expr-is-aggregation = ?Count(_)
  expr-is-aggregation = ?Max(_)                 
  expr-is-aggregation = ?Min(_)                 
  expr-is-aggregation = ?Avg(_)                 
  expr-is-aggregation = ?Sum(_)                 
  expr-is-aggregation = ?Conj(_)                
  expr-is-aggregation = ?Disj(_)                
  expr-is-aggregation = ?Concat(_)
  
  expr-remove-partial: Partial(s,e) -> e
  expr-remove-partial: e -> e where not(expr-is-partial)

  expr-is-relationref: Ref(entityName) -> NoRelation(Ref(entityName)) where not(<is-relationname> entityName)

  expr-to-partial-expr = expr-is-relationref
  expr-to-partial-expr: expr -> result
  where
    not(expr-is-relationref);
    not(expr-to-partial-expr-type)
  with
    annotations := <get-annotations> expr;
    arg* := <get-arguments>expr;
    exp_args* := <map(expr-to-partial-expr)>arg*;
    constr := <get-constructor>expr;
    relations := <collect-all(expr-is-norelation)> exp_args*;
    if <?[]> relations then
      newterm_plain := <mkterm>(constr, <map(expr-remove-partial)> exp_args*);
      newterm := <set-annotations> (newterm_plain, annotations);
      result := Partial("String",newterm)
    else
      result_plain := <mkterm>(constr, exp_args*);
      result := <set-annotations> (result_plain, annotations)
    end
    
  expr-to-partial-expr-type: w @ LitString(str1)                 -> Partial("String", w)
  expr-to-partial-expr-type: w @ Int(i_1)                        -> Partial("String", w)
  expr-to-partial-expr-type: w @ Float(f_1)                      -> Partial("String", w)
  expr-to-partial-expr-type: w @ True()                          -> Partial("String", w)
  expr-to-partial-expr-type: w @ False()                         -> Partial("String", w)
  expr-to-partial-expr-type: w @ Datetime(str1)                  -> Partial("String", w)
  expr-to-partial-expr-type: w @ NoValue()                       -> Partial("String", w)
  
  expr-to-partial-expr = expr-to-partial-expr-type

  partial-expr-add-name(|prefix): (Partial(s,e), history) -> result
    with
      (s', history') := <new-name>(prefix, history);
      result := (Partial(s',e), history')
  
  partial-expr-add-name(|prefix): (expr, history) -> (expr, history)
    where not(<expr-is-partial> expr)

  partial-expr-add-names(|prefix): expr -> expr'
    with
      (expr', _) := <topdown-fold-keep-anno(try(partial-expr-add-name(|prefix)))> (expr, [])
   
