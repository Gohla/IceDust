module expressions-math

imports

  signatures/-

rules
  
  [[ Addition(e1, e2) ^ (s) : TTuple(out_type, out_mult) ]] :=
    [[ e1 ^ (s) : TTuple(e1_type, e1_mult) ]],
    [[ e2 ^ (s) : TTuple(e2_type, e2_mult) ]],
    AdditionType(e1_type) == None(),
    LeastUpperBound(e1_type, e2_type) == out_type,
    CartesianProduct(e1_mult, e2_mult) == out_mult.
  
  [[ Subtraction(e1, e2) ^ (s) : TTuple(out_type, out_mult) ]] :=
    [[ e1 ^ (s) : TTuple(e1_type, e1_mult) ]],
    [[ e2 ^ (s) : TTuple(e2_type, e2_mult) ]],
    SubtractionType(e1_type) == None(),
    LeastUpperBound(e1_type, e2_type) == out_type,
    CartesianProduct(e1_mult, e2_mult) == out_mult.
  
  [[ Division(e1, e2) ^ (s) : TTuple(TFloat(), out_mult) ]] :=
    [[ e1 ^ (s) : TTuple(e1_type, e1_mult) ]],
    [[ e2 ^ (s) : TTuple(e2_type, e2_mult) ]],
    DivisionType(e1_type) == None(),
    LeastUpperBound(e1_type, e2_type) == out_type, // don't use out-type, because division of ints is also float
    IsType(out_type) == None(),                    // but make sure it evaluates to something
    DivisionMult(CartesianProduct(e1_mult, e2_mult), e2) == out_mult.
  
  [[ FloorDivision(e1, e2) ^ (s) : TTuple(out_type, out_mult) ]] :=
    [[ e1 ^ (s) : TTuple(e1_type, e1_mult) ]],
    [[ e2 ^ (s) : TTuple(e2_type, e2_mult) ]],
    DivisionType(e1_type) == None(),
    LeastUpperBound(e1_type, e2_type) == out_type,                    // type rule identical to Multiplication
    DivisionMult(CartesianProduct(e1_mult, e2_mult), e2) == out_mult. // mult rule identical to Division

  [[ Modulo(e1, e2) ^ (s) : TTuple(out_type, out_mult) ]] := // identical to FloorDivision
    [[ e1 ^ (s) : TTuple(e1_type, e1_mult) ]],
    [[ e2 ^ (s) : TTuple(e2_type, e2_mult) ]],
    DivisionType(e1_type) == None(),
    LeastUpperBound(e1_type, e2_type) == out_type,
    DivisionMult(CartesianProduct(e1_mult, e2_mult), e2) == out_mult.
  
  [[ Multiplication(e1, e2) ^ (s) : TTuple(out_type, out_mult) ]] :=
    [[ e1 ^ (s) : TTuple(e1_type, e1_mult) ]],
    [[ e2 ^ (s) : TTuple(e2_type, e2_mult) ]],
    DivisionType(e1_type) == None(),
    LeastUpperBound(e1_type, e2_type) == out_type,
    CartesianProduct(e1_mult, e2_mult) == out_mult.
  
 