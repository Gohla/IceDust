module analysis2/analysis2

imports // constructors
  
  signatures/Expressions-sig
//  api/_runtime-constructors
  analysis2/constructors

imports // functions

  analysis2/path
//  api/_runtime
//  api/execute-api
  api/data-api
  api/data-names-api
//  api/model-api
  api/model-names-api
//  api/module-api
  api/module-names-api
//  lib/nabl-ext
  lib/graph
  lib/index
  lib/lists-tuples
//  lib/string
  lib/origin
  lib/traverse
//  names/naming/names
//  naming/_notNaBL
  lib/nabl2

rules

  nabl2-after-analysis(|source,ast): analysis -> ([],[],[],analysis)
//    with
//      <debug>source;
//      <debug>ast;
//      <debug>analysis
    with
      <store-analysis>analysis
    with
      modulename := <collect-one(is-modulename)>ast
    with
      <depends-on-and-flows-to-2>modulename
    with
      <flows-toposort-2>modulename
    with
      if <check-nabl2-attachments>ast then
        <ast-store-membervalues>ast
      end

//  analysis2 =
//    analysis2-clear-index;
//    store-expressions;
//    depends-on-and-flows-to-2;
//    flows-toposort-2
//
//rules
//
//  analysis2-clear-index: a -> a
//    with
//      <_index-clear-source>"analysis2"

rules

  check-nabl2-attachments = where(collect-all(is-string);(map(nabl2--get-ast-index) <+ filter(not(nabl2--get-ast-index));debug(!"The following terms do not have an nabl2 attachment ");fail))
  nabl2--get-ast-index = fail //is an internal nabl2 strategy

rules

  ast-store-membervalues: ast -> ast
    with
      memvs     := <collect-all(is-membervalue)>ast;
      memvs-a   := <filter(where(membervalue-get-name;membervaluename-is-attribute            ))>memvs;
      memvs-rri := <filter(where(membervalue-get-name;membervaluename-is-relation-role-inverse))>memvs;
      memvs-s   := <filter(where(membervalue-get-name;membervaluename-is-shortcut             ))>memvs
    with
      assoc1* := <fmap(membervalue-rri-assocs)>memvs-rri;
      assoc2* := <fmap(membervalue-s-assocs  )>memvs-s;
      assoc*  := [assoc1*, assoc2*]
    with
      <debug(!"assocs       ")>assoc*
    with
      <map(index-add-prop(|Assoc()))>assoc*
      
  membervalue-rri-assocs: memv -> [assoc1*, assoc2*]
    with
      name        := <membervalue-get-name>memv;
      name2origin := <membervalue-get-name;membervaluename-get-origin;name-get-inversename>memv;
      ei          := <membervalue-get-name;membervaluename-get-entityinstancename>memv;
      expr        := <membervalue-get-expr>memv;
      ei2*        := <map(entityinstance-get-name;get-decl(|"Member"))>expr
    with
      assoc1* := <map(\ei2->(name,                                                      ei2)\)>ei2*;
      assoc2* := <map(\ei2->(<entityinstancename-get-membervaluename(|name2origin)>ei2, ei )\)>ei2*  //TODO: entityinstancename-get-membervaluename on ei2 with name2 might not exist in scope graph. Can I create a new definition? -> (ei2, name2, ei) can be encoded as (name2', ei) where name2' is a definition in the scope of ei2
      
  membervalue-s-assocs: memv -> assoc*
    with
      assoc* := <membervalue-get-expr;fmap(membervalue-s-expr-assocs(|memv))>memv

  membervalue-s-expr-assocs(|memv): expr -> [assoc1, assoc2, assoc3, assoc4]
    with
      name         := <membervalue-get-name>memv;
      eiName       := <membervalue-get-name;membervaluename-get-entityinstancename>memv;
      eiName2      := <entityinstance-get-name;get-decl(|"Member")>expr;
      roleName1    := <membervaluename-get-origin;shortcutname-get-rolename1>name;
      roleName2    := <membervaluename-get-origin;shortcutname-get-rolename2>name;
      inverseName1 := <rolename-get-inversename>roleName1;
      inverseName2 := <rolename-get-inversename>roleName2;
      if riName    := <relation-instance-get-name>expr then
        id
      else
        relationName  := <attributename-get-entityname>roleName1;
        modulename    := <entityinstancename-get-modulename>eiName;
        riName-string := <custom-origin(|name)>$[[eiName][<ucfirst>eiName2][<ucfirst>relationName]];
        riName        := <entityinstancename-get-modulename;modulename-get-entityinstancename(|riName-string)>eiName
      end;
      memv-r1-name := <entityinstancename-get-membervaluename(|roleName1)>riName;
      memv-r2-name := <entityinstancename-get-membervaluename(|roleName2)>riName;
      memv-i1-name := <entityinstancename-get-membervaluename(|inverseName1)>eiName;
      memv-i2-name := <entityinstancename-get-membervaluename(|inverseName2)>eiName2
    with
      assoc1 := (memv-i1-name, riName);
      assoc2 := (memv-r1-name, eiName);
      assoc3 := (memv-r2-name, eiName2);
      assoc4 := (memv-i2-name, riName)

//  module-store-expr: mod -> mod
//    with
//      exprs := <collect-all(is-execute);fmap(execute-get-exprs)>mod;
//      name  := <module-get-modulename>mod;
//      <index-store-prop(|AST(), name)>exprs

rules

  depends-on-and-flows-to-2: modulename -> modulename
    with
      attributenames := <modulename-get-attributenames-default-derivation>modulename
//    with
//      <debug>attributenames
    with
      dependencies := <fmap(attrname-dependencies)>attributenames;
      dataflow     := <map(path-inverse)>dependencies
    with
      <debug(!"dependencies ")>dependencies;
      <debug(!"dataflow     ")>dataflow
    with
      <map(path-store-on-origin)>dependencies;
      <map(path-store-on-origin)>dataflow

  attrname-dependencies: attrName -> dependencies
    with
      expr              := <attributename-get-expr>attrName;
      (p*, q*)          := <expr-pathexprs>expr;
      pathexprs         := [p*, q*];
      pathexprs-no-this := <filter(not(?This()));map(pathexpr-remove-this;pathexpr-remove-shortcuts)>pathexprs;
      all-pathexprs     := <fmap(pathexpr-shorten-refl-trans);make-set>pathexprs-no-this;
      dependencies      := <map(path(|attrName))>all-pathexprs;
      dataflow          := <map(path-inverse)>dependencies
      
rules

  flows-toposort-2: moduleName -> moduleName
    with
      attributeNames* := <modulename-get-attributenames>moduleName;
      relationNames*  := <modulename-get-relationnames-left>moduleName;
      roleNames*      := <modulename-get-rolenames>moduleName;
      graphNames      := [attributeNames*, relationNames*, roleNames*];
      toposort        := <graph-topological-sort(toposort-edge)>graphNames;
      <index-set(|moduleName, TopoSort())>toposort;
      numbers     := <add-indices;map(zip-repeat-1);concat;map(tuple-reverse)>toposort;
      <map(index-set-prop(|TopoSort()))>numbers

  toposort-edge: name -> [names*, inv-names*]
    with
      names* := <index-get2(|FlowsTo());map(path-last)>name;
      if inv-name := <name-get-inversename>name then
        inv-names* := <index-get2(|FlowsTo());map(path-last)>inv-name
      else
        inv-names* := []
      end
