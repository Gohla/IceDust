module analysis2/analysis2

imports // constructors
  
  signatures/Expressions-sig
//  api/_runtime-constructors
  analysis2/constructors

imports // functions

  analysis2/path
//  api/_runtime
//  api/execute-api
  api/data-api
  api/data-names-api
//  api/model-api
  api/model-names-api
//  api/module-api
  api/module-names-api
//  lib/nabl-ext
  lib/graph
  lib/index
  lib/lists-tuples
//  lib/string
  lib/traverse
//  names/naming/names
//  naming/_notNaBL
  lib/nabl2

rules

  nabl2-after-analysis(|source,ast): analysis -> ([],[],[],analysis)
//    with
//      <debug>source;
//      <debug>ast;
//      <debug>analysis
    with
      <store-analysis>analysis
    with
      modulename := <collect-one(is-modulename)>ast
    with
      <depends-on-and-flows-to-2>modulename
    with
      <flows-toposort-2>modulename
    with
      if <check-nabl2-attachments>ast then
        <ast-store-membervalues>ast
      end

//  analysis2 =
//    analysis2-clear-index;
//    store-expressions;
//    depends-on-and-flows-to-2;
//    flows-toposort-2
//
//rules
//
//  analysis2-clear-index: a -> a
//    with
//      <_index-clear-source>"analysis2"

rules

  check-nabl2-attachments = where(collect-all(is-string);(map(nabl2--get-ast-index) <+ filter(not(nabl2--get-ast-index));debug(!"The following terms do not have an nabl2 attachment ");fail))
  nabl2--get-ast-index = fail //is an internal nabl2 strategy

rules

  ast-store-membervalues: ast -> ast
    with
      memvs     := <collect-all(is-membervalue)>ast;
      memvs-a   := <filter(where(membervalue-get-name;membervaluename-is-attribute            ))>memvs;
      memvs-rri := <filter(where(membervalue-get-name;membervaluename-is-relation-role-inverse))>memvs;
      memvs-s   := <filter(where(membervalue-get-name;membervaluename-is-shortcut             ))>memvs
    with
      <debug(!"memvs     ")>memvs;
      <debug(!"memvs-a   ")>memvs-a;
      <debug(!"memvs-rri ")>memvs-rri;
      <debug(!"memvs-s   ")>memvs-s
    with
      assoc1* := <fmap(membervalue-rri-assocs)>memvs-rri;
      assoc2* := <fmap(membervalue-s-assocs  )>memvs-s
    with
      <debug>assoc1*;
      <debug>assoc2*
      
  membervalue-rri-assocs: memv -> [assoc1*, assoc2*]
    with
      name  := <membervalue-get-name;membervaluename-get-origin>memv;
      name2 := <name-get-inversename>name;
      ei    := <membervalue-get-name;membervaluename-get-entityinstancename>memv;
      expr  := <membervalue-get-expr>memv;
      ei2*  := <map(entityinstance-get-name)>expr
    with
      assoc1* := <map(\ei2->(ei ,name ,ei2)\)>ei2*;
      assoc2* := <map(\ei2->(ei2,name2,ei )\)>ei2*  //TODO: entityinstancename-get-membervaluename on ei2 with name2 might not exist in scope graph. Can I create a new definition? -> (ei2, name2, ei) can be encoded as (name2', ei) where name2' is a definition in the scope of ei2
      
  membervalue-s-assocs: memv -> []
    with
      id //TODO: on `foo{rel=foo2}` requires treating as `foo{rel=<noname1{}>foo2}` which requires creating a new definition of EntityInstance in data scope (if I want to NaBL2 based code gen)
         //TODO: other option is to create a completely new data structure as model, and do AST -> ScopeGraph -> Model -> Java rather than AST -> ScopeGraph as Model -> Java

//  store-expressions: ast -> ast
//    with
//      attrs  := <collect(is-attr);filter(where(attr-get-derivation))>ast;
//      <map(attr-store-expr)>attrs;
//      memvs := <collect-all(is-membervalue)>ast;
//      <map(membervalue-store-expr)>memvs;
//      <module-store-expr>ast
//  
//  attr-store-expr: attr -> attr
//    with
//      derivation := <attr-get-derivation>attr;
//      attrName   := <attr-get-name>attr;
//      <index-store-prop(|AST(), attrName)>derivation
//      
//  membervalue-store-expr: memv -> memv
//    with
//      expr := <membervalue-get-expr>memv;
//      expr':= <try(sometd(entityinstance-to-entityinstanceref))>expr;
//      name := <membervalue-get-name>memv;
//      <index-store-prop(|AST(), name)>expr';
//      eiNamesTuples := <membervalue-getall-einames;filter((?None()<+is-entityinstancename,is-entityinstancename))>expr' // not all identifiers might be resolved in erroneous programs
//    with
//      if <membervaluename-is-relation <+ membervaluename-is-role <+ membervaluename-is-inverse>name then
//        eiNames := <map(Snd)>eiNamesTuples;
//        <map(index-store-prop    (|Rel(),    name))>eiNames;
//        eiName := <membervaluename-get-entityinstancename>name;
//        names  := <map(entityinstancename-get-membervaluename(|<membervaluename-get-origin;name-get-inversename>name))>eiNames;
//        <map(index-store-prop-inv(|RelInv(), eiName))>names
//      end
//    with
//      if <membervaluename-is-shortcut>name then
//        invName := <get-member-origin;shortcutname-get-inversename>name;
//        invvalueName := <membervaluename-get-entityinstancename;entityinstancename-get-membervaluename(|invName)>name;
//        <index-store-def>invvalueName;
//        <index-store-prop(|NablProp_member-origin(), invvalueName)>invName;
//        roleName := <get-member-origin;shortcutname-get-rolename>name;
//        <map(store-shortcut-helper(|invvalueName, invName, roleName))>eiNamesTuples
//      end
//      
//  store-shortcut-helper(|invvalueName, invName, roleName): (riName, eiName2) -> None()
//    with
//      eiName       := <membervaluename-get-entityinstancename>invvalueName;
//      relationName := <attributename-get-entityname>roleName;
//      if None() := riName then
//        riName-string := $[[eiName][<ucfirst>eiName2][<ucfirst>relationName]];
//        riName' := <entityinstancename-get-modulename;modulename-get-entityinstancename(|riName-string)>eiName;
//        <index-store-def>riName';
//        <index-store-prop(|Type(), riName')><_get-type>invName
//      else
//        riName' := riName
//      end;
//      <index-store-prop(|Rel(), invvalueName)>riName';
//      <index-store-prop(|RelInv(), <entityinstancename-get-membervaluename(|<name-get-inversename>invName)>riName')>eiName;
//      rolevalueName := <entityinstancename-get-membervaluename(|roleName)>riName';
//      <index-store-def>rolevalueName;
//      <index-store-prop(|NablProp_member-origin(), rolevalueName)>roleName;
//      <index-store-prop(|Rel(), rolevalueName)>eiName2;
//      <index-store-prop(|RelInv(), <entityinstancename-get-membervaluename(|<name-get-inversename>roleName)>eiName2)>riName'
//  
//  module-store-expr: mod -> mod
//    with
//      exprs := <collect-all(is-execute);fmap(execute-get-exprs)>mod;
//      name  := <module-get-modulename>mod;
//      <index-store-prop(|AST(), name)>exprs

rules

  depends-on-and-flows-to-2: modulename -> modulename
    with
      attributenames := <modulename-get-attributenames-default-derivation>modulename
//    with
//      <debug>attributenames
    with
      dependencies := <fmap(attrname-dependencies)>attributenames;
      dataflow     := <map(path-inverse)>dependencies
    with
      <debug(!"dependencies ")>dependencies;
      <debug(!"dataflow     ")>dataflow
    with
      <map(path-store-on-origin)>dependencies;
      <map(path-store-on-origin)>dataflow

  attrname-dependencies: attrName -> dependencies
    with
      expr              := <attributename-get-expr>attrName;
      (p*, q*)          := <expr-pathexprs>expr;
      pathexprs         := [p*, q*];
      pathexprs-no-this := <filter(not(?This()));map(pathexpr-remove-this;pathexpr-remove-shortcuts)>pathexprs;
      all-pathexprs     := <fmap(pathexpr-shorten-refl-trans);make-set>pathexprs-no-this;
      dependencies      := <map(path(|attrName))>all-pathexprs;
      dataflow          := <map(path-inverse)>dependencies
      
rules

  flows-toposort-2: moduleName -> moduleName
    with
      attributeNames* := <modulename-get-attributenames>moduleName;
      relationNames*  := <modulename-get-relationnames-left>moduleName;
      roleNames*      := <modulename-get-rolenames>moduleName;
      graphNames      := [attributeNames*, relationNames*, roleNames*];
      toposort        := <graph-topological-sort(toposort-edge)>graphNames;
      <index-set(|moduleName, TopoSort())>toposort;
      numbers     := <add-indices;map(zip-repeat-1);concat;map(tuple-reverse)>toposort;
      <map(index-set-prop(|TopoSort()))>numbers

  toposort-edge: name -> [names*, inv-names*]
    with
      names* := <index-get2(|FlowsTo());map(path-last)>name;
      if inv-name := <name-get-inversename>name then
        inv-names* := <index-get2(|FlowsTo());map(path-last)>inv-name
      else
        inv-names* := []
      end
