module lib/nabl2

imports // functions

  api/_generated
  api/_runtime
  lib/debug
  lib/lists-tuples
  nabl2/api

signature constructors

  Namespace : String -> Namespace

  
rules // store analysis to be able to query without passing the analysis
  
  store-analysis: path -> None()
    where
      is-string
    with
      analysis := <nabl2-get-resource-analysis>$[[<_project-path>]/[path]];
      rules(StoredAnalysis : None() -> analysis)
  
  store-analysis: analysis -> None()
    where
      not(is-string)
    with
      rules(StoredAnalysis : None() -> analysis)
  
  get-stored-analysis = !None();StoredAnalysis <+ fatal-err(|"Error: Analysis is not stored. Please store with <store-analysis>path.")    

rules // wrap nabl2 api with stored analysis

  get-type-property         = nabl2-get-type(|<get-stored-analysis>)
  get-property(|prop)       = nabl2-get-property(|<get-stored-analysis>,prop)
  get-all-decls(|)          = nabl2-get-all-decls(|<get-stored-analysis>)
  get-all-refs(|)           = nabl2-get-all-refs(|<get-stored-analysis>)
  get-all-scopes(|)         = nabl2-get-all-scopes(|<get-stored-analysis>)
  get-ref-scope(|)          = nabl2-get-ref-scope(|<get-stored-analysis>)
  get-decl-scope(|)         = nabl2-get-decl-scope(|<get-stored-analysis>)
  get-scope-decls(|)        = nabl2-get-scope-decls(|<get-stored-analysis>)
  get-scope-refs(|)         = nabl2-get-scope-refs(|<get-stored-analysis>)
  get-scope-direct-edges(|) = nabl2-get-scope-direct-edges(|<get-stored-analysis>)
  get-scope-named-edges(|)  = nabl2-get-scope-named-edges(|<get-stored-analysis>)
  get-decl-assocs(|)        = nabl2-get-decl-assocs(|<get-stored-analysis>)
  get-scope-assocs(|)       = nabl2-get-scope-assocs(|<get-stored-analysis>)
  get-scope-reachables(|ns) = nabl2-get-scope-reachables(|<get-stored-analysis>, ns)
  get-resolved-name(|)      = nabl2-get-resolved-name(|<get-stored-analysis>)

rules // compose nabl2 calls (hide occurrence behind namespaces)

  get-type-property(|ns)            = nabl2-mk-occurrence(|ns);get-type-property
  get-property(|ns, prop)           = get-decl(|ns);nabl2-mk-occurrence(|ns);get-property(|prop) //@type Term -> Term //TODO: make this work for references as well
//  get-property(|ns, prop)           = nabl2-mk-occurrence(|ns);get-property(|prop)   //@type Term -> Term
  get-decl-assocs-with-labels(|ns)  = nabl2-mk-occurrence(|ns);get-decl-assocs       //@type Term -> List((Label,Scope))
  get-decl-assoc-with-labels(|ns)   = get-decl-assocs-with-labels(|ns);Hd            //@type Term -> (Label,Scope)
  get-decl-assocs(|ns)              = get-decl-assocs-with-labels(|ns);map(Snd)      //@type Term -> List(Scope)
  get-decl-assoc(|ns)               = get-decl-assocs(|ns);Hd                        //@type Term -> Scope
  get-decl-scope(|ns)               = nabl2-mk-occurrence(|ns);get-decl-scope        //@type Term -> Scope
  get-ref-scope(|ns)                = nabl2-mk-occurrence(|ns);get-ref-scope         //@type Term -> Scope
  get-scope(|ns)                    = get-decl-scope(|ns)+get-ref-scope(|ns)         //@type Term -> Scope
  get-scope-decl-names              = get-scope-decls;map(nabl2-get-occurrence-name) //@type Scope -> List(Term)
  get-scope-decl-names(|ns)         = get-scope-decl-names;filter(is-decl(|ns))      //@type Scope -> List(Term)
  get-scope-assoc-names-with-labels = get-scope-assocs;map(split2(nabl2-get-occurrence-name,id)) //@type Scope -> List((Term,Label))
  get-scope-assoc-name-with-label   = get-scope-assoc-names-with-labels;Hd           //@type Scope -> (Term, Label)
  get-scope-assoc-names             = get-scope-assoc-names-with-labels;map(Fst)     //@type Scope -> List(Term)
  get-scope-assoc-name              = get-scope-assoc-names;Hd                       //@type Scope -> Term
  get-scope-reachable-names(|ns)    = get-scope-reachables(|ns);map(nabl2-get-occurrence-name) //@type Scope -> List(Term)
  get-scope-reachable-names2(|ns)   = get-scope-reachable-names(|ns) <+ ![]          //@type Scope -> List(Term)
  get-scope-direct-edge-scopes      = get-scope-direct-edges;map(Snd)                //@type Scope -> List(Scope)
  get-scope-direct-edge-scope       = get-scope-direct-edge-scopes;Hd                //@type Scope -> Scope
  get-resolved-name(|ns)            = nabl2-mk-occurrence(|ns);get-resolved-name;Fst;nabl2-get-occurrence-name //@Type Term -> Term
  is-decl(|ns)                      = where(get-decl-scope(|ns))                     //@type Term -> Term
  is-ref(|ns)                       = where(get-ref-scope(|ns))                      //@type Term -> Term
  get-decl(|ns)                     = is-decl(|ns)                                   //@Type Term -> Term
  get-decl(|ns)                     = is-ref(|ns);get-resolved-name(|ns)             //@Type Term -> Term
//  get-decl(|ns)                     = debug(|"get-decl: is-decl and is-ref both failed, defaulting to decl")

imports

  nabl2/runtime/analysis/main

rules // stuff that depends on nabl2 internals

  // something similar should be in the public api
  /**
   * Get reachable declarations of a scope
   *
   * @param ns : String
   * @type Scope -> List(Occurrence)
   */
  nabl2-get-scope-reachables(|a, ns) = ?s;!Reachables(s,Namespace(ns));nabl2--get-names(|<nabl2--sol-g>a)
  
  // overrides nabl2/runtime/analysis/main.str/nabl2--analyze(pre)
  nabl2--analyze(pre):
    AnalyzeUnit(source,ast,initial) -> UnitResult(ast',[Constraint(C)])
    where not(<nabl2--is-empty-ast> ast)
    with nabl2--analysis-step(!$[Preprocessing AST [source]],
      params := <getfirst(?Params(<id>))> initial;
      ast' := <pre;nabl2--index-ast(|source)> ast
    )
    with nabl2--analysis-step(!$[Generating constraints [source]],
      C := <nabl2--generate-constraint-file(|source,params);nabl2--normalize-constraint> ast'
    )
    with nabl2--analysis-step(!$[Storing AST [source]],
      rules(StoredAst : source -> ast)
//      ; <collect-all(is-string);map(debug;try(nabl2--get-ast-index);debug)>ast
    )
  
  // overrides nabl2/runtime/analysis/main.str/nabl2--analyze(pre)
  nabl2--analyze(pre):
    AnalyzeFinal(source,initial,unit*) -> FinalResult([error*,error2*],[warning*,warning2*],[note*,note2*],analysis2)
    with nabl2--analysis-step(!"Normalizing constraints",
      C  := <getfirst(?Constraint(<id>))> initial;
      C* := <map(getfirst(?Constraint(<id>)))> unit*;
      C' := <nabl2--normalize-constraint> CConj([C|C*])
    )
    with nabl2--analysis-step(!"Solving constraints",
    {| AnalysisTiming:
      lo* := <join(nabl2--label-lt)> (<nabl2--labels>,<nabl2--labels>);
      sol1* := <nabl2--solve-facts> [(<nabl2--initial-solution>,[C'])];
      sol2* := <map(({ sol1, g:
        ?sol1;
        g := <nabl2--sol-g> sol1;
        ![ InitialScopeGraph(g)
         | sol1
         ]
      },id))> sol1*;
      sol3* := <nabl2--solve-constraints> sol2*;
      sol4* := <map(Fst)> sol3*; // discard constraint part
      timing := <nabl2--get-analysis-timing;qsort(where((Snd;Snd,Snd;Snd);gt))>
    |})
    where nabl2--analysis-step(!"Processing solutions",
    with(
      (good,bad) := <partition(not(nabl2--is-erronious));(length,length)> sol4*;
      try(nabl2-debug-analysis-hook; <debug> $[Found [<int-to-string> good] correct and [<int-to-string> bad] erronious solutions.])
    );
    where(
      sol := <Hd> sol4*
    );
    with(
      error* := <nabl2--sol-e;nabl2--mapv(nabl2--xmlencode)> sol;
      warning* := <nabl2--sol-w;nabl2--mapv(nabl2--xmlencode)> sol;
      note* := <nabl2--sol-n;nabl2--mapv(nabl2--xmlencode)> sol;
      resolution := <nabl2--sol-r;map((nabl2--occurrence-index,Fst;nabl2--occurrence-index))> sol;
      analysis := [ Constraint(C')
                  , ResolutionParams(<nabl2--labels>,<nabl2--labels-wf>,lo*)
                  , Timing(timing)
                  , AlternativeSolutions(<(Tl<+![]);map-with-index(id)> sol4*)
                  | sol
                  ]
    ))
    with( nabl2--analysis-step(!$[Retreiving AST [source]],
      ast := <StoredAst>source
    ));
    where( nabl2--analysis-step(!"2nd-phase analysis",
    with(
      (error2*,warning2*,note2*,analysis2) := <nabl2-after-analysis(|source,ast) <+ !([],[],[],analysis)>analysis
    )))
  
  // something similar should be in the public api
  /**
   * Do a 2nd-phase analysis after NaBL2 analysis
   *
   * @param source : String
   * @param ast : Term
   * @type analysis -> (error*,warning*,note*,analysis)
   */
  nabl2-after-analysis(|source,ast) = fail
