module Expressions

imports
	Common
	Types

context-free syntax // brackets

  Exp                    = <(<Exp>)>               {bracket}

context-free syntax // operators

  Exp.MemberAccess       = <<Exp> . <ID>>          {left}
  Exp.Not                = <!<Exp>>                {right}
  
  Exp.Cast               = <<Exp> as <PrimitiveType>> {right}

  Exp.Multiplication     = <<Exp> * <Exp>>         {left}
  Exp.Division           = <<Exp> / <Exp>>         {left}
  Exp.Modulo             = <<Exp> % <Exp>>         {left}
  Exp.Addition           = <<Exp> + <Exp>>         {left}
  Exp.Subtraction        = <<Exp> - <Exp>>         {left}

  Exp.LessThan           = <<Exp> \< <Exp>>        {left}
  Exp.LessThanEqual      = <<Exp> \<= <Exp>>       {left}
  Exp.GreaterThan        = <<Exp> \> <Exp>>        {left}
  Exp.GreaterThanEqual   = <<Exp> \>= <Exp>>       {left}
  Exp.Equal              = <<Exp> == <Exp>>        {left}
  Exp.Inequal            = <<Exp> != <Exp>>        {left}
  Exp.And                = <<Exp> && <Exp>>        {left}
  Exp.Or                 = <<Exp> || <Exp>>        {left}
  Exp.TernaryConditional = <<Exp> ? <Exp> : <Exp>> {right}

  Exp.Merge              = <<Exp> ++ <Exp>>        {left}
  Exp.ChoiceLeft         = <<Exp> \<+ <Exp>>       {left}

context-free syntax // built-in functions

  Exp.Min                = <min ( <Exp> )>
  Exp.Max                = <max ( <Exp> )>
  Exp.Avg                = <avg ( <Exp> )>
  Exp.Sum                = <sum ( <Exp> )>
  Exp.Concat             = <concat ( <Exp> )>
  Exp.Count              = <count ( <Exp> )>
  Exp.Conj               = <conj ( <Exp> )>
  Exp.Disj               = <disj ( <Exp> )>

context-free syntax // references

  Exp.This               = <this>
  Exp.Ref                = <<ID>>
  
context-free syntax // literal values

  Exp                    = <<LitVal>>
  LitVal.Int             = <<INT>>
  LitVal.Float           = <<FLOAT>>
  LitVal.True            = <true>
  LitVal.False           = <false>
  LitVal.Datetime        = <<DATETIME>>

syntax // literal values: use kernel syntax to make sure " abc " is parsed as String(" abc ") instead of String("abc")

	LitVal-CF.String = "\"" STRING-LEX "\""

context-free priorities

	{ left:
		Exp.MemberAccess
	} >	
	{ right:
		Exp.Not
	} >
	{ right:
		Exp.Cast
	} >
	{ left:
		Exp.Multiplication
		Exp.Division
		Exp.Modulo
	} >
	{ left:
		Exp.Addition
		Exp.Subtraction
	} >
	{ left:
		Exp.LessThan
		Exp.LessThanEqual
		Exp.GreaterThan
		Exp.GreaterThanEqual
	} >
	{ left:
		Exp.Equal
		Exp.Inequal
	} >
	{ left:
		Exp.And
	} >
	{ left:
		Exp.Or
	} >
	{ right:
		Exp.TernaryConditional
	} >
	{ left:
		Exp.Merge
	} >
	{ left:
		Exp.ChoiceLeft
	}
