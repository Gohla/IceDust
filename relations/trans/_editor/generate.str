module trans/_editor/generate

imports
	
	lib/editor-common.generated
	lib/index/-
	lib/task/-
	
	trans/generating/generate
	trans/lib/files
	
	include/Relations
	trans/desugaring/desugar
	trans/_editor/analysis

rules // Builders
	
	generate-java      = generate-java(error-handler-editor)
	generate-java-test = generate-java(error-handler-tests)
	generate-java(error-handler):
		(selected, position, ast, path, project-path) -> result
		with
			result := <build(error-handler)>(selected, path, project-path, 1)
	
	compile-java       = compile-java(error-handler-editor)
	compile-java-test  = compile-java(error-handler-tests)
	compile-java(error-handler):
		(selected, position, ast, path, project-path) -> None()
		with
			<build(error-handler)>(selected, path, project-path, 2)
	
	execute-java       = execute-java(error-handler-editor);debug;\ _ -> None() \
	execute-java-test  = execute-java(error-handler-tests)
	execute-java(error-handler):
		(selected, position, ast, path, project-path) -> result
		with
			result := <build(error-handler)>(selected, path, project-path, 3)

rules // Error handlers (editor: report error, do not fail, tests: fail with error)

	error-handler-editor : msg -> ("ERROR_PLACEHOLDER", msg)
		with
			err-msg(|msg)

	error-handler-tests : msg -> None()
		with
			with(fail|msg)

rules // Build in steps
	
	build(error-handler):
		(ast, path, project-path, i) -> result
		with
			index-setup(|<language>, project-path);
			task-setup(|project-path);

			if Module(_,_,_,_) := ast then
				// log(|Info(),"Phase 0: Analyzing");
				(ast', error*) := <analyze-ast-step> (ast, path, project-path)
			else
				ast' := ast;
				error* := <task-get-messages(|$[[project-path]/[path]])>
			end;
			
			if not([] := error*) then
				<error-handler>"Fix errors before generating code. Exiting code generation.";
				result := None()
			else

			if <leq>(1, i) then
				// log(|Info(),"Phase 1: Generating Java Code");
				(javaFileName, javaCode, error') := <generate-java-step(error-handler)>(ast', path);
				<copy-java-libraries>(javaFileName, project-path);
				if <eq>(1, i) then
					result := (javaFileName, javaCode)
				end;
				
			if not([] := error') then
				<error-handler>"Fix errors compiling Java. Exiting code compilation.";
				result := None()
			else
				
			if <leq>(2, i) then
				// log(|Info(),"Phase 2: Compiling Java Code");
				<write-file> (javaFileName, javaCode);
				(exitCode, output, classFileName) := <compile-java-step> (javaFileName, project-path);
				if <eq>(2, i) then
					result := None()
				end;

			if not(0 := exitCode) then
				<error-handler>output;
				<error-handler>"Java compilation failed. Exiting code execution.";
				result := None()
			else
				
			if <leq>(3, i) then
				// log(|Info(),"Phase 3: Executing");
				(exitCode', output') := <execute-java-step> classFileName;
				result := output'
				
			end end end end end end
	
	analyze-ast-step: (ast, path, project-path) -> (analyzed-ast, error*)
		with
			(analyzed-ast, [error*|_], warning*, note*) := <analysis-single-default-interface>(ast, path, project-path)
	
	generate-java-step(error-handler) = generate-java-code(error-handler)
	
	copy-java-libraries: (javaFileName, project-path) -> None()
		with
			sourceDir := $[[<plugin-path>]/lib-java/src/lib];
			targetDir := $[[<dirname>$[[project-path]/[javaFileName]]]/lib];
			<copy-dir>(sourceDir, targetDir);
			<dirname;refresh-workspace-file> targetDir
	
	compile-java-step:
		(javaFileName, project-path) -> (exitCode, output, classFileName)
		with
			(exitCode, output) := <call-read-output> ("javac", ["-cp", <dirname>$[[project-path]/[javaFileName]], javaFileName]);
			classFileName := <guarantee-extension(|"class")> javaFileName;
			<dirname;refresh-workspace-file> $[[project-path]/[javaFileName]]

	execute-java-step:
		classFileName -> (exitCode, output)
		with
			classPath := <dirname>classFileName;
			className := <base-filename;remove-extension> classFileName;
			(exitCode, output) := <call-read-output> ("java", ["-cp", classPath, className])

rules // call helper
	
	call-read-output: (program, args) -> (exitCode, <conc-strings> (errors, output))
		with
		  Stream(instream)   := <stdin-stream>;
		  Stream(filestream) := <fopen> ("stdout.txt", "w");
		  Stream(filestream2):= <fopen> ("stderr.txt", "w")
		with
		  // log(|Info(), ["Calling external tool ", program, " ", <try(separate-by(|" "); concat-strings)> args]);
		  exitCode := <prim("SSL_EXT_call", program, args, instream, filestream, filestream2)>
		with
		  <fclose>filestream;
		  <fclose>filestream2;
		  output := <read-text-file> "stdout.txt";
		  errors := <read-text-file> "stderr.txt";
		  <delete-file>"stdout.txt";
		  <delete-file>"stderr.txt"

