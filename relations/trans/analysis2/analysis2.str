module analysis2/analysis2

imports // constructors
	
	signatures/Expressions-sig
	api/_runtime-constructors
	analysis2/constructors

imports // functions

	analysis2/path
	api/_runtime
	api/data-api
  api/execute-api
	api/model-api
	api/model-names-api
	api/module-api
	api/module-names-api
	lib/nabl-ext
	lib/graph
	lib/index
	lib/lists-tuples

rules

	analysis2 =
		analysis2-clear-index;
		store-expressions;
//		depends-on-and-flows-to;
//		flows-toposort;
		depends-on-and-flows-to-2;
    flows-toposort-2

rules

	analysis2-clear-index: a -> a
		with
			<_index-clear-source>"analysis2"

rules
	
	store-expressions: ast -> ast
		with
			attrs  := <collect(is-attr);filter(where(attr-get-derivation))>ast;
			<map(attr-store-expr)>attrs;
			einsts := <collect-all(is-entityinstance)>ast;
			<map(einst-store-expr)>einsts;
      <module-store-expr>ast
	
	attr-store-expr: attr -> attr
		with
			derivation := <attr-get-derivation>attr;
			attrName   := <attr-get-name>attr;
			<index-store-prop(|AST(), attrName)>derivation
  
  einst-store-expr: einst -> einst
    with
      exprs := <concat(entityinstance-get-rolevalues,entityinstance-get-attrvalues)>einst;
      exprs':= <try(sometd(entityinstance-to-entityinstanceref))>exprs;
      name  := <entityinstance-get-name>einst;
      <map(index-store-prop(|AST(), name))>exprs'
  
  module-store-expr: mod -> mod
    with
      exprs := <collect-all(is-execute);map(execute-get-exprs);flatten-list>mod;
      name  := <module-get-modulename>mod;
      <index-store-prop(|AST(), name)>exprs
/*
rules
	
	depends-on-and-flows-to: ast -> ast
		with
			attrs      := <collect(is-attr)>ast;
			paths      := <map(attr-depends-on);concat>attrs;
			<map(path-store-on-origin(|DependsOn()))>paths;
			invPaths   := <map(path-reverse;path-all-tails);concat>paths;
			<map(path-store-on-origin(|FlowsTo()))>invPaths

	attr-depends-on: attr -> []
		where
			not(attr-get-derivation)

	attr-depends-on: attr -> paths
		where
			derivation := <attr-get-derivation>attr
		with
			attrName   := <attr-get-name>attr;
			pathExprs  := <collect(?MemberAccess(_,_)<+?Ref(_))>derivation;
			paths      := <map(expr-to-path(|attrName));filter(path-isvalid);map(path-no-shortcuts);give-all-tasks-results-anno;replace-use-with-defs-anno>pathExprs

rules
	
	flows-toposort: ast -> ast
		with
			moduleName  := <module-get-modulename>ast;
			entityNames := <modulename-get-entitynames>moduleName;
			graphNames  := <map(concat(entityname-get-attributenames,entityname-get-rolenames));concat>entityNames;
			toposort    := <graph-topological-sort(index-get-prop(|FlowsTo());map(path-get-last))>graphNames;
			<index-store-prop(|TopoSort(), moduleName)>toposort;
			numbers     := <add-indices;map(zip-repeat-1);concat;map(tuple-reverse)>toposort;
			<map(index-store-prop(|TopoSort()))>numbers
*/
rules

  depends-on-and-flows-to-2: ast -> ast
    with
      attrs  := <collect(is-attr);filter(where(attr-get-derivation))>ast;
      <map(attr-depends-on-and-flows-to)>attrs
      
  attr-depends-on-and-flows-to: attr -> attr
    with
      attrName          := <attr-get-name>attr;
      expr              := <attr-get-derivation>attr;
//      <pp-partial-Relations-string;debug>expr;
//      <debug>expr;
      pathexprs         := <expr-pathexprs>expr;
//      <map(pp-partial-Relations-string;debug(|"pathexprs"))>pathexprs;
      pathexprs-no-this := <map(pathexpr-remove-this;pathexpr-remove-shortcuts)>pathexprs;
      all-pathexprs     := <map(pathexpr-shorten-refl-trans);flatten-list;make-set>pathexprs-no-this;
      dependencies      := <map(path(|attrName))>all-pathexprs;
//      <map(path-pp;debug)>dependencies;
      dataflow          := <map(path-inverse)>dependencies;
//      <map(path-pp;debug)>dataflow;
      <map(path-store-on-origin)>dependencies;
      <map(path-store-on-origin)>dataflow
      
rules

  flows-toposort-2: ast -> ast
    with
      moduleName      := <module-get-modulename>ast;
      attributeNames* := <modulename-get-attributenames>moduleName;
      relationNames*  := <modulename-get-relationnames-left>moduleName;
      roleNames*      := <modulename-get-rolenames>moduleName;
      graphNames      := [attributeNames*, relationNames*, roleNames*];
      toposort        := <graph-topological-sort(toposort-edge)>graphNames;
      <index-store-prop(|TopoSort(), moduleName)>toposort;
      numbers     := <add-indices;map(zip-repeat-1);concat;map(tuple-reverse)>toposort;
      <map(index-store-prop(|TopoSort()))>numbers

  toposort-edge: name -> [names*, inv-names*]
    with
//      <debug(|"toposort-edge")>name;
      names* := <index-get-prop(|FlowsTo());map(path-last)>name;
//      <map(debug(|"x"))>names*;
      if inv-name := <name-get-inversename>name then
        inv-names* := <index-get-prop(|FlowsTo());map(path-last)>inv-name//;
//        <map(debug(|"y"))>inv-names*
      else
        inv-names* := []
      end