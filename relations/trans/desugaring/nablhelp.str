module trans/desugaring/nablhelp

imports
	
	trans/api/model-api
	trans/api/rules-api
	
	// include/Relations
	// src-gen/signatures/Rules-sig
	trans/desugaring/constructors
		
	trans/lib/traverse
	trans/lib/origin
	
rules
	
	nablhelp =
		nablhelp1;
		nablhelp2;
		nablhelp3;
		nablhelp4;
		nablhelp5;
		nablhelp6
	
	nablhelp1 = try(sometd(entity-add-shortcut-types)) //requires the roles to be untouched
	nablhelp2 = try(sometd(role-duplicate-type))
	
	nablhelp3 = try(sometd(rule-variable-def-use))
	nablhelp4 = bottomup(try(variable-def-defbyrel)) //requires variables to be def-use (bottomup-try because nesting)
	
	nablhelp5 = try(sometd(rule-attr-variable-def-use))
	nablhelp6 = try(sometd(rule-rhs-attr-variable-use)) //cleans up the previous rule


rules // add types to shortcuts (so we can define in those types the shortcuts)
	
	// entity-add-shortcut-types: Entity(a,entityName,members) -> Entity(a,entityName,members')
	// 	with
	// 		role-types := <filter(role-name-and-type)>members;
	// 		members' := <map(try(add-shortcut-types(|role-types)))> members
	
	entity-add-shortcut-types: e -> <entity-set-members(|members')>e
		where
			is-entity
		with
			members := <entity-get-members>e;
			role-types := <filter(role-name-and-type)>members;
			members' := <map(try(add-shortcut-types(|role-types)))> members
	
	// role-name-and-type: Role(type, _, name, _) -> (name, type)
	
		role-name-and-type: r -> (<role-get-name>r, <role-get-type>r)
	
	// add-shortcut-types(|role-types): Shortcut(rr1@RoleRef(role1), b, rr2@RoleRef(role2), f) ->
	// 																 Shortcut(NaBLHelp(rr1, type1), b, NaBLHelp(rr2, type2), f)
	// 	with
	// 		type1 := <role-type>(role1, role-types);
	// 		type2 := <role-type>(role2, role-types)
			
	add-shortcut-types(|role-types): s -> <create-shortcut(|role1, type1, shortcut1, role2, type2, shortcut2)>
		where
			is-shortcut
		with
			(role1, role2) := <shortcut-get-roles>s;
			type1 := <role-type>(role1, role-types);
			type2 := <role-type>(role2, role-types);
			(shortcut1, shortcut2) := <shortcut-get-shortcuts>s
		
	role-type : (role, role-types) -> type
		with
			(_, type) := <filter(role-type(|role));first>role-types
		<+
			type := ""
	
	role-type(|role): (role2, type) -> <id>
		where
			<eq>(role, role2)

	first: [a] -> a
	first: [a|_] -> a

rules // duplicate role types (so one can define and one can refer)

	// role-duplicate-type: Role(a, b, c, d) -> Role(NaBLHelp(a, a), b, c, d)
	
	role-duplicate-type = role-set-type(\a -> NaBLHelp(a, a)\)

rules // figure out which node names are defs and which are uses
	
	// rule-variable-def-use: Rule(n, p, b) -> Rule(n, p, b'')
	// 	with
	// 		params := (<map(\Param(n,t,m)->n\)>p, [], []); //(lhs, nhs, rhs) vars
	// 		(b', _) := <topdown-fold-cond(try(variable-def-use),?SubRule(_,_))>(b, params);
	// 		b'' := <custom-origin(|b)>b'
	
	rule-variable-def-use: r -> <rule-set-body(|b')>r
		where
			is-rule
		with
			params := (<rule-get-params;map(param-get-name)>r, [], []); //(lhs, nhs, rhs) vars
			(b', _) := <topdown-fold-cond(try(variable-def-use),is-subrule)>(<rule-get-body>r, params)
			
// 	variable-def-use: (n@LHSNode(name, er, v), history) -> (<custom-origin(|n)>LHSNode(n-name, er, v), history')
// 		with
// 			(n-name, history') := <lhs-var-def-use>(name, history)	
// 
// 	variable-def-use: (n@NHSNode(name, er, v), history) -> (<custom-origin(|n)>NHSNode(n-name, er, v), history')
// 		with
// 			(n-name, history') := <nhs-var-def-use>(name, history)	
// 			
// 	variable-def-use: (n@RHSNode(name, er, v), history) -> (<custom-origin(|n)>RHSNode(n-name, er, v), history')
// 		with
// 			(n-name, history') := <rhs-var-def-use>(name, history)

	variable-def-use: (n, history) -> (<node-set-varname(|n-name)>n, history')
		where
			<is-node>n;
			<is-lhs>n
		with
			(n-name, history') := <lhs-var-def-use>(<node-to-varname>n, history)

	variable-def-use: (n, history) -> (<node-set-varname(|n-name)>n, history')
		where
			<is-node>n;
			<is-nhs>n
		with
			(n-name, history') := <nhs-var-def-use>(<node-to-varname>n, history)

	variable-def-use: (n, history) -> (<node-set-varname(|n-name)>n, history')
		where
			<is-node>n;
			<is-rhs>n
		with
			(n-name, history') := <rhs-var-def-use>(<node-to-varname>n, history)	

// 	variable-def-use: (n@LHSEdgeName(name), history) -> (<custom-origin(|n)>LHSEdgeName(n-name), history')
// 		with
// 			(n-name, history') := <lhs-var-def-use>(name, history)
// 
// 	variable-def-use: (n@NHSEdgeName(name), history) -> (<custom-origin(|n)>NHSEdgeName(n-name), history')
// 		with
// 			(n-name, history') := <nhs-var-def-use>(name, history)
// 
// 	variable-def-use: (n@RHSEdgeName(name), history) -> (<custom-origin(|n)>RHSEdgeName(n-name), history')
// 		with
// 			(n-name, history') := <rhs-var-def-use>(name, history)

	variable-def-use: (e, history) -> (<edge-set-varname(|n-name)>e, history')
		where
			<is-edge>e;
			<is-lhs>e
		with
			debug;
			(n-name, history') := <lhs-var-def-use>(<edge-get-varname>e, history)

	variable-def-use: (e, history) -> (<edge-set-varname(|n-name)>e, history')
		where
			<is-edge>e;
			<is-nhs>e
		with
			debug;
			(n-name, history') := <nhs-var-def-use>(<edge-get-varname>e, history)

	variable-def-use: (e, history) -> (<edge-set-varname(|n-name)>e, history')
		where
			<is-edge>e;
			<is-rhs>e
		with
			debug;
			(n-name, history') := <rhs-var-def-use>(<edge-get-varname>e, history)

	lhs-var-def-use: (name, (lhs, nhs, rhs)) -> (name', (lhs', nhs, rhs))
		with
			if !(name, lhs);not(elem) then
				lhs' := <conc>(lhs, [name]);
				defuse := Def()
			else
				lhs' := lhs;
				defuse := Use()
			end;
			name' := NaBLHelp(name, <custom-origin(|name)>defuse)
			
	nhs-var-def-use: (name, (lhs, nhs, rhs)) -> (name', (lhs, nhs', rhs))
		with
			if and(!(name, lhs);not(elem), !(name, nhs);not(elem)) then
				nhs' := <conc>(nhs, [name]);
				defuse := Def()
			else
				nhs' := nhs;
				defuse := Use()
			end;
			name' := NaBLHelp(name, <custom-origin(|name)>defuse)		
			
	rhs-var-def-use: (name, (lhs, nhs, rhs)) -> (name', (lhs, nhs, rhs'))
		with
			if and(!(name, lhs);not(elem), !(name, rhs);not(elem)) then
				rhs' := <conc>(rhs, [name]);
				defuse := Def()
			else
				rhs' := rhs;
				defuse := Use()
			end;
			name' := NaBLHelp(name, <custom-origin(|name)>defuse)

rules // if node names are Def and there is a relation change to DefByRel
	
	variable-def-defbyrel: LHSEdge(e, n@LHSNode(nh@NaBLHelp(v, Def()), None(), a)) -> 
	                       LHSEdge(e, <custom-origin(|n)>LHSNode(<custom-origin(|nh)>NaBLHelp(v, DefByRel()), None(), a))
	variable-def-defbyrel: NHSEdge(e, n@NHSNode(nh@NaBLHelp(v, Def()), None(), a)) -> 
	                       NHSEdge(e, <custom-origin(|n)>NHSNode(<custom-origin(|nh)>NaBLHelp(v, DefByRel()), None(), a))
	variable-def-defbyrel: RHSEdge(e, n@RHSNode(nh@NaBLHelp(v, Def()), None(), a)) -> 
	                       RHSEdge(e, <custom-origin(|n)>RHSNode(<custom-origin(|nh)>NaBLHelp(v, DefByRel()), None(), a))

rules // make attributes in matches either Binds or Uses
	
	rule-attr-variable-def-use: Rule(n, p, b) -> Rule(n, p, b'')
		with
			params := <map(\Param(n,t,m)->n\)>p;
			(b', _) := <topdown-fold(try(attr-def-use))>(b, params);
			b'' := <custom-origin(|b)>b'
	
	attr-def-use: (at, history) -> (at'', history')
		where
			Attr(a, r) := at
		with
			if Ref(name) := r ; <not(elem)>(name, history) then
				history' := <conc>(history, [name]);
				at' := Attr(NaBLHelp(a, <custom-origin(|a)>Bind()), name)
			else
				history' := history;
				at' := Attr(NaBLHelp(a, <custom-origin(|a)>Use()), r)
			end;
			at'' := <custom-origin(|at)>at'

rules // make attributes in rhs always uses
	
	rule-rhs-attr-variable-use: RuleBody(l,n,r,s) -> RuleBody(l,n,r'',s)
		with
			r' := <try(sometd(attr-variable-use))>r;
			r'' := <custom-origin(|l)>r'
	
	attr-variable-use: Attr(NaBLHelp(a, Bind()), name) -> Attr(NaBLHelp(a, <custom-origin(|a)>Use()), <custom-origin(|name)>Ref(name))
