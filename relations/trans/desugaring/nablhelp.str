module trans/desugaring/nablhelp

imports // constructors
	
	trans/api/constructors

imports // functions

	trans/api/model-api
	trans/api/rules-api
	trans/lib/traverse
	trans/lib/origin
	
rules
	
	nablhelp-before =
		nablhelp1;
		nablhelp2;
		nablhelp3;
		nablhelp4;
		nablhelp5;
		nablhelp6
	
	nablhelp1 = try(sometd(entity-add-shortcut-types)) //requires the roles to be untouched
	nablhelp2 = try(sometd(role-duplicate-type))
	
	nablhelp3 = try(sometd(rule-variable-def-use))
	nablhelp4 = bottomup(try(variable-def-defbyrel)) //requires variables to be def-use (bottomup-try because nesting)
	
	nablhelp5 = try(sometd(rule-attr-variable-def-use))
	nablhelp6 = try(sometd(node-rhs-attr-variable-use)) //cleans up the previous rule

	nablhelp-after = 
		try(sometd(role-duplicate-type-reverse <+ shortcut-add-type-reverse <+ attr-def-use-reverse));
		bottomup(try(variable-def-use-reverse))

rules // add types to shortcuts (so we can define in those types the shortcuts)
	
	entity-add-shortcut-types: e -> <entity-set-members(|members')>e
		where
			is-entity
		with
			members := <entity-get-members>e;
			role-types := <filter(role-name-and-type)>members;
			members' := <map(try(add-shortcut-types(|role-types)))> members
	
	role-name-and-type: r -> (<role-get-name>r, <role-get-type>r)
			
	add-shortcut-types(|role-types): s -> <create-shortcut(|role1, type1, shortcut1, role2, type2, shortcut2)>
		where
			is-shortcut
		with
			(role1, role2) := <shortcut-get-roles>s;
			type1 := <role-type>(role1, role-types);
			type2 := <role-type>(role2, role-types);
			(shortcut1, shortcut2) := <shortcut-get-shortcuts>s
		
	role-type : (role, role-types) -> type
		with
			(_, type) := <filter(role-type(|role));Hd>role-types
		<+
			type := ""
	
	role-type(|role): (role2, type) -> <id>
		where
			<eq>(role, role2)

rules // duplicate role types (so one can define and one can refer)
	
	role-duplicate-type = role-dup-type

rules // figure out which node names are defs and which are uses
	
	rule-variable-def-use: r -> <rule-set-body(|b')>r
		where
			is-rule
		with
			params := (<rule-get-params;map(param-get-name)>r, [], []); //(lhs, nhs, rhs) vars
			(b', _) := <topdown-fold-cond(try(variable-def-use),is-subrule)>(<rule-get-body>r, params)

	variable-def-use: (n, history) -> (<node-to-defbytype>n, history')
		where
			<is-node>n
		with
			(defuse, history') := <varname-def-use(|<get-hs>n)>(<node-get-varname>n, history)
		where
			Def() := defuse	

	variable-def-use: (e, history) -> (<edge-to-def>e, history')
		where
			<is-edge>e
		with
			(defuse, history') := <varname-def-use(|<get-hs>e)>(<edge-get-varname>e, history)
		where
			Def() := defuse	

	varname-def-use(|hs): (name, history) -> (defuse, history')
		with
			if and(!(name, <hs-history-get(|LHS())>history);not(elem), !(name, <hs-history-get(|hs)>history);not(elem)) then
				history' := <hs-history-add(|hs,name)>history;
				defuse := Def()
			else
				history' := history;
				defuse := Use()
			end

	hs-history-get(|hs) = where(LHS():=hs);?(<id>, _, _)
	hs-history-get(|hs) = where(RHS():=hs);?(_, _, <id>)

	hs-history-add(|hs, name) = where(LHS():=hs);(list-add(|name), id, id)
	hs-history-add(|hs, name) = where(RHS():=hs);(id, id, list-add(|name))
	
	list-add(|i): a -> [i|a]

rules // if node names are Def and there is a relation change to DefByRel

	variable-def-defbyrel: e -> <edge-set-node2(|n')>e
		where
			is-edge;
			n := <edge-get-node2>e;
			<node-has-no-type>n;
			<node-is-def>n
		with
			n' := <node-to-defbyrel>n
	
rules // make attributes in matches either Binds or Uses
	
	rule-attr-variable-def-use: r -> <rule-set-body(|b')>r
		where
			is-rule
		with
			param-names := <rule-get-params;map(param-get-name)>r;
			(b', _) := <topdown-fold(try(attr-def-use))>(<rule-get-body>r, param-names)

	attr-def-use: (at, history) -> (at', history')
		where
			<is-attr>at
		where
			name := <attr-get-expr-ref-name>at; <not(elem)>(name, history)
		with
			varName := <attr-get-name>at;
			history' := <list-add(|name)> history;
			at' := <attr-to-bindvar>at

rules // make attributes in rhs always uses
	
	node-rhs-attr-variable-use: n -> <node-set-params(map(try(attr-to-not-bindvar)))>n
		where
			is-node;
			is-rhs

rules
	
	role-duplicate-type-reverse = role-dedup-type
	
rules
	
	shortcut-add-type-reverse =
		where(is-shortcut);
		?s;
		create-shortcut(|<shortcut-get-role1>s, <shortcut-get-shortcut1>s, <shortcut-get-role1>s, <shortcut-get-shortcut2>s)
		
rules
	
	attr-def-use-reverse = 
		attr-to-not-bindvar

rules
	
	variable-def-use-reverse = 
		node-to-not-def <+ edge-to-not-def
	
