module trans/desugaring/omitted

imports
	
	// lib/runtime/editor/origins
	lib/editor/origins
	
	trans/lib/origin
	trans/lib/new-name
	trans/lib/string
	trans/lib/traverse
	include/Relations
	src-gen/signatures/Rules-sig
	trans/api/model-api
	trans/api/rules-api

rules
	
	generate-omitted =
		bottomup(try(omitted1));
		bottomup(try(omitted2));
		bottomup(try(omitted3))
	
	omitted1 = attr-generate-mult
	omitted1 = role-generate-name
	omitted1 = entity-generate-inverse-names
	omitted1 = datadef-generate-entity-names
	omitted1 = param-generate-mult
	omitted1 = subrule-generate-mult
	omitted1 = node-move-name-to-type
	
	omitted2 = entity-generate-shortcuts        // requires role-generate-name
	omitted2 = rule-generate-node-names         // requires node-move-name-to-type
	
	omitted3 = rule-generate-param-node-matches // requires param-generate-mult, matches same as rule-generate-node-names
	omitted3 = edge-generate-name								// requires rule-generate-node-names

rules // generate omitted multiplicities

	attr-generate-mult: attr -> attr'
		where	attr-has-no-mult
		with attr':= <attr-set-mult(|One())>attr

rules // generate omitted role names

	role-generate-name: role -> role'
		where role-has-no-name
		with role' := <role-set-name(|<role-get-type;origin-track-forced(lcfirst)>role)>role
			
rules // generate omitted inverse names
	
	entity-generate-inverse-names: Entity(a,entityName,roles) -> Entity(a,entityName,roles')
		with
			roles' := <map(try(generate-inverse-name(|entityName)))>roles

	generate-inverse-name(|entityName): role -> role'
		where role-has-no-inversename
		with role' := <role-set-inversename(|<custom-origin(lcfirst|<role-get-type>role)>entityName)>role

rules	// generate omitted entity names

	datadef-generate-entity-names: DataDef(c) -> DataDef(c'')
		with
			(c', _) := <map-fold(try(generate-entity-name))>(c, []);
			c'' := <custom-origin(|c)>c'

	generate-entity-name: (ei@EntityInstance(er@EntityRef(e-ty), None(), r, a), history) -> (<custom-origin(|ei)>EntityInstance(er, <custom-origin(|e-ty)>e, r, a), history')
		with
			(e, history') := <new-name>(<lcfirst>e-ty, history)
	
rules // generate omitted shortcuts

	entity-generate-shortcuts: Entity(a,entityName,members) -> Entity(a,entityName,members'')
		with
			roles 				:= <filter(role-name);origin-track-forced(string-sort)>members;
			shortcuts			:= <filter(shortcut-roles)>members;
			shortcuts-all := <join-half>roles;
			shortcuts-add := <diff>(shortcuts-all, shortcuts);
			members-new		:= <map(create-shortcut)>shortcuts-add;
			members'			:= <conc>(members,members-new);
			members''			:= <custom-origin(|members)>members'
			
	role-name: Role(_, _, name, _) -> name
	
	shortcut-roles: Shortcut(RoleRef(role1), _, RoleRef(role2), _) -> <string-sort;ListToTuple>[role1,role2]
	
	join-half: [] -> []
	
	join-half: [h|t] -> <conc>(r,r2)
		with
			r := <join-half> t;
			r2:= <map(pair-with(|h))>t
			
	pair-with(|h): t -> (h,t)

	create-shortcut: (role1,role2) -> Shortcut(rr1, role2, rr2, role1)
		with
			rr1 := <custom-origin(|role1)>RoleRef(role1);
			rr2 := <custom-origin(|role2)>RoleRef(role2)

rules // generate omitted multiplicities

	param-generate-mult: Param(a, b, None()) -> Param(a, b, One())

	subrule-generate-mult: SubRule(None(), a) -> SubRule(One(), a)
	
rules // move name to type if capitalized
	
	node-move-name-to-type: node -> node''
		where
			node-has-no-type;
			node-var := <node-to-varname>node;
			<first-is-upper>node-var
		with
			node' := <node-set-type(|node-var)>node;
			node'' := <node-set-varname(|None())>node'
			
rules // generate omitted node names

	rule-generate-node-names: Rule(r, p, b) -> Rule(r, p, b'')
		with
			(b', _) := <topdown-fold(try(generate-node-name))>(b, []);
			b'' := <custom-origin(|b)>b'

	generate-node-name: (node, history) -> (node', history')
		where
			<node-has-no-varname>node;
			node-ty := <node-to-type>node
		with
			(node-var', history') := <new-name>(<lcfirst>node-ty, history);
			node' := <node-set-varname(|node-var')>node

rules // generate omitted edge names

	edge-generate-name: edge -> edge'
		where
			edge-has-no-varname
		with
			(node1-var, _, node2-var) := <edge-to-varnames>edge;
			edge-model := <edge-to-edgemodel>edge;
			edge-var' := <concat-strings;custom-origin(|edge-model)> [node1-var, <ucfirst>edge-model, <ucfirst>node2-var];
			edge' := <edge-set-varname(|edge-var')>edge

rules // generated omitted param node matches
	
	rule-generate-param-node-matches: Rule(r, p, b@RuleBody(lhs,nhs,rhs,sub)) -> Rule(r, p, b'')
		with
			p-match := <filter(rule-param-one-to-match)>p;
			b' := RuleBody(<conc>(p-match,lhs),nhs,rhs,sub);
			b'' := <custom-origin(|b)>b'
	
	rule-param-one-to-match: Param(name, EntityRef(_), One()) -> <custom-origin(|name)>LHSNode(name, None(), None())
	
