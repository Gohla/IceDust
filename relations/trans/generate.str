module generate

imports

	lib/editor-common.generated
	include/Relations
	lib/java/Java
	lib/java/pretty-print
	desugar
	properties
	names
	lib/index/-
	lib/task/-
	lib/nabl/-
	

rules // Builders
	
	generate-java:
		(selected, position, ast, path, project-path) -> (fileName, result)
		with
			index-setup(|<language>, project-path);
			task-setup(|project-path);
			(fileName, result) := <generate-java>(selected, path)
			
	compile-java:
		(selected, position, ast, path, project-path) -> None()
		with
			index-setup(|<language>, project-path);
			task-setup(|project-path);
			(javaFileName, _) := <generate-java>(selected, path);
			<compile-java> javaFileName
			
	execute-java:
		(selected, position, ast, path, project-path) -> None()
		with
			index-setup(|<language>, project-path);
			task-setup(|project-path);
			(javaFileName, _) := <generate-java>(selected, path);
			classFileName := <compile-java> javaFileName;
			<execute-java> classFileName
			

	generate-java:
	    (selected, path) -> (fileName, result)
	    with
			fileName := <guarantee-extension(|"java")> path;
			java-ast := <to-java> selected;
			result   := <pp-java-string> java-ast;
			<write-file> (fileName, result)
			
	compile-java:
		javaFileName -> classFileName
		with
			<try(call)> ("javac", [javaFileName]);
			classFileName := <guarantee-extension(|"class")> javaFileName;
			<refresh-workspace-file> classFileName

	execute-java:
		classFileName -> None()
		with
			classPath := <dirname>classFileName;
			className := <base-filename;remove-extension> classFileName;
			<try(call)> ("java", ["-cp", classPath, className])
			


rules // Helper rules : file writer

	write-file: (fileName, content) -> (fileName, content)
		where
			<dirname;ensure-dir> fileName
		where
			fileDescriptor := <fopen> (fileName, "w");
			<fputs> (content, fileDescriptor);
			<fclose> fileDescriptor;
			<refresh-workspace-file> fileName
			
	ensure-dir: path -> path
		where
			<file-exists;filemode;isdir> path
	ensure-dir: path -> path
		where
			<not(file-exists;filemode;isdir)> path;
			<dirname;ensure-dir> path;
			<mkdir> path



rules // Transformation to java ast.

  to-java:
    [_] -> <concat-strings> <map(to-java)>
    
  to-java:
    () -> ""
    
  to-java:
  	None() -> ""

  to-java: Module(_,_,_,_) -> <fail>
  	where
  		err-msg(|"Desugar before generating code.")
  		// ; with(fail|"Desugar before generating code.")


// Module
  to-java:
    ModuleDesugared(moduleName, model, data, execute) ->
CompilationUnit(
  None()
, [ TypeImportDec(
      TypeName(
        PackageOrTypeName(PackageOrTypeName(Id("java")), Id("util"))
      , Id("Collection")
      )
    )
  , TypeImportDec(
      TypeName(
        PackageOrTypeName(PackageOrTypeName(Id("java")), Id("util"))
      , Id("HashSet")
      )
    )
  ]
, <concat>[[ mainClass ], modelJava]
)
	where
		mainClass := <main-class-to-java>ModuleDesugared(moduleName, model, data, execute);
		modelJava := <to-java>model
		
  main-class-to-java: ModuleDesugared(moduleName, model, data, execute) ->
	  ClassDec(
	      ClassDecHead([], Id(moduleName), None(), None(), None())
	    , ClassBody(
	        [ MethodDec(
	            MethodDecHead(
	              [Public(), Static()]
	            , None()
	            , Void()
	            , Id("main")
	            , [ Param(
	                  []
	                , ArrayType(ClassOrInterfaceType(TypeName(Id("String")), None()))
	                , Id("args")
	                )
	              ]
	            , None()
	            )
	          , Block(
	           	<concat>[
	              dataJava,
	              executeJava
	              ]
	            )
	          )
	        ]
	      )
	    )
	where
		dataJava := <to-java>data;
		if Executable(_) := execute then
			executeJava := <to-java>execute
		else
			executeJava := []
		end


// Model
  to-java: ModelDef(model) -> <map(try(to-java))>model

  to-java: EntityTypeDef(_, name, attributesAndRoles) -> 
	  ClassDec(
	      ClassDecHead([], Id(name), None(), None(), None())
	    , ClassBody(
	      	<concat>[[ConstrDec(
	            ConstrDecHead([Public()], None(), Id(name), [], None())
	          , ConstrBody(
	              None()
	            , fulfillRolesJavaInit
	            )
	          )],
	      		attributesAndRolesJava,
	      		fulfillRolesJava	
	      	]
	      )
	    )
	where
		attributesAndRolesJava := <map(to-java);concat>attributesAndRoles;
		fulfillRoles := <get-fulfill-role <+ empty-list>name;
		// <debug> fulfillRoles;
		// <debug> <get-fulfill-role-multiple <+ empty-list>name;
		fulfillRolesJava := <map(to-java-fullfil-role) <+ empty-list> fulfillRoles;
		fulfillRolesJavaInit := <map(to-java-fulfill-role-init) <+ empty-list> fulfillRoles
	
	empty-list: _ -> []
	
	to-java-fullfil-role: fulfillRole@_ ->
			FieldDec(
        [Public()]
      , ClassOrInterfaceType(
          TypeName(Id("Collection"))
        , Some(TypeArgs([ClassOrInterfaceType(TypeName(Id(relationName)), None())]))
        )
      , [VarDec(Id($[[relationName]_[roleName]]))]
      )
		where
			relationName := <de-def;nabl-uri-parent;nabl-uri-name>fulfillRole;
			roleName := <de-def;nabl-uri-name>fulfillRole
			
	to-java-fulfill-role-init: fulfillRole@_ ->
			ExprStm(
	      Assign(
	        ExprName(Id($[[relationName]_[roleName]]))
	      , NewInstance(
	          None()
	        , ClassOrInterfaceType(
	            TypeName(Id("HashSet"))
	          , Some(TypeArgs([ClassOrInterfaceType(TypeName(Id($[[relationName]])), None())]))
	          )
	        , []
	        , None()
	        )
	      )
	    )
		where
			relationName := <de-def;nabl-uri-parent;nabl-uri-name>fulfillRole;
			roleName := <de-def;nabl-uri-name>fulfillRole

	de-def: Def(x) -> x

  to-java: Attribute(name, PrimitiveType(type), derivation) ->
		[ field
	    , setter
	    , MethodDec(
	        MethodDecHead(
	          [Public()]
	        , None()
	        , ClassOrInterfaceType(TypeName(Id(javaType)), None())
	        , Id($[get_[name]])
	        , []
	        , None()
	        )
	      , Block(
	        	[Return(Some(getterExpr))]
	        )
	      )
	     ]
		where
			javaType := <to-java>type;
			derivationType := <get-derivation-type <+ err-msg(|$[Could not get derivation type of Attribute.])>name;
			if Normal() := derivationType then
				field := <field>(name, javaType);
				setter := <setter>(name, javaType);
				getterExpr := ExprName(Id(name))
			else if DefaultValue() := derivationType then
				field := <field>(name, javaType);
				setter := <setter>(name, javaType);
				Derivation(derivationExpr, _) := derivation;
				getterExpr := Cond(
	                      NotEq(ExprName(Id(name)), <null-value>type)
	                    , ExprName(Id(name))
	                    , <to-java>derivationExpr
	                    )
			else if Derivation() := derivationType then
				field := [];
				setter := [];
				Derivation(derivationExpr, _) := derivation;
				getterExpr := <to-java>derivationExpr
			end end end
	
	field: (name, javaType) ->
				FieldDec(
	        [Private()]
	      , ClassOrInterfaceType(TypeName(Id(javaType)), None())
	      , [VarDec(Id(name))]
	      )
	
	setter: (name, javaType) ->
		MethodDec(
      MethodDecHead(
        [Public()]
      , None()
      , Void()
      , Id($[set_[name]])
      , [Param(
           []
         , ClassOrInterfaceType(TypeName(Id(javaType)), None())
         , Id(name)
         )]
      , None()
      )
    , Block(
        [ExprStm(
           Assign(Field(This(), Id(name)), ExprName(Id(name)))
         )]
      )
    )

  to-java: Role(EntityType(type), multiplicity, roleName) ->
		[	FieldDec(
	      [Public()]
	    , ClassOrInterfaceType(TypeName(Id(type)), None())
	    , [VarDec(Id(roleName))]
	    )
		]

  to-java: "String" -> "String"
  to-java: "Int"	-> "int"

	to-java: AttributeName(name) -> Invoke(Method(MethodName(Id($[get_[name]]))), [])
	
	null-value: "String" -> Lit(Null())
	null-value: "Int" -> Lit(Deci("0"))

// Data
  to-java: DataDef(defs) -> <map(to-java);concat> defs
  
  to-java: EntityOrRelation(
        EntityType(entityType)
      , entityName
      , roleValues
      , attributeValues
      )
      ->
      <concat>[[
      LocalVarDecStm(
          LocalVarDec(
            []
          , ClassOrInterfaceType(TypeName(Id(entityType)), None())
          , [ VarDec(
                Id(entityName)
              , NewInstance(
                  None()
                , ClassOrInterfaceType(TypeName(Id(entityType)), None())
                , []
                , None()
                )
              )
            ]
          )
        )],
        attributeValuesJava,
        roleValuesJava
        ]
	where
		attributeValuesJava := <map(to-java(|entityName))> attributeValues;
		roleValuesJava			:= <map(to-java(|entityName, entityType));concat> roleValues

  to-java(|entityName) : AttributeValue(AttributeName(attributeName), attributeValue) ->
	  	ExprStm(
        Invoke(
          Method(MethodName(AmbName(Id(entityName)), Id($[set_[attributeName]])))
        , [attributeValueJava]
        )
	    )
    where
    	attributeValueJava := <to-java>attributeValue
    	
  to-java(|entityName, entityType) :
  	RoleValue(RoleName(roleName), EntityName(otherEntityName)) ->
  	[	
  		ExprStm(
		      Assign(
		        ExprName(AmbName(Id(entityName)), Id(roleName))
		      , ExprName(Id(otherEntityName))
		      )
		    )
		  , ExprStm(
		      Invoke(
		        Method(
		          MethodName(
		            AmbName(AmbName(Id(otherEntityName)), Id($[[entityType]_[roleName]]))
		          , Id("add")
		          )
		        )
		      , [ExprName(Id(entityName))]
		      )
		    )
		 ]
  

  to-java: String(value) -> Lit(String([Chars(value)]))
  to-java: Integer(value) -> Lit(Deci(value))


// Execute
  to-java: Executable(executes) -> <map(to-java)>executes
  
  to-java: AccessEntityAttribute(EntityName(entityName), attributeName) ->
  		ExprStm(
          Invoke(
            Method(
              MethodName(
                AmbName(AmbName(Id("System")), Id("out"))
              , Id("println")
              )
            )
          , [Invoke(
               Method(MethodName(AmbName(Id(entityName)), Id($[get_[attributeName]])))
             , []
             )]
          )
        )


// Debugging	          
  to-java: a -> []
  	where
		  warn-msg(|$[No to-java defined for [<get-constructor> a]/[<get-arguments;length> a].])

	    