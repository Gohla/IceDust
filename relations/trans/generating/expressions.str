module trans/generating/expressions

imports

	include/Relations
	lib/java/Java

	trans/generating/expressions-navigators
	trans/generating/expressions-references
	trans/generating/types

rules

	exp-to-java-stm(err) = nav-to-java(err)
	exp-to-java-stm(err) = ref-to-java(err)

rules // math

	exp-to-java-stm(err): e@Addition(e1, e2)			-> <lib-java-bin-exp(err)>(e, e1, e2, "plus")
	exp-to-java-stm(err): e@Subtraction(e1, e2)		-> <lib-java-bin-exp(err)>(e, e1, e2, "minus")
	exp-to-java-stm(err): e@Division(e1, e2) 			-> <lib-java-bin-exp(err)>(e, e1, e2, "div")
	exp-to-java-stm(err): e@Modulo(e1, e2) 				-> <lib-java-bin-exp(err)>(e, e1, e2, "mod")
	exp-to-java-stm(err): e@Multiplication(e1, e2)-> <lib-java-bin-exp(err)>(e, e1, e2, "mul")

rules // logic
	
	exp-to-java-stm(err): e@Not(e1)								-> <lib-java-un-exp(err)>(e, e1, "not")
	exp-to-java-stm(err): e@LessThan(e1, e2)			-> <lib-java-bin-exp(err)>(e, e1, e2, "lt")	
	exp-to-java-stm(err): e@LessThanEqual(e1, e2)	-> <lib-java-bin-exp(err)>(e, e1, e2, "lte")	
	exp-to-java-stm(err): e@GreaterThan(e1, e2)		-> <lib-java-bin-exp(err)>(e, e1, e2, "gt")	
	exp-to-java-stm(err): e@GreaterThanEqual(e1,e2)-><lib-java-bin-exp(err)>(e, e1, e2, "gte")	
	exp-to-java-stm(err): e@Equal(e1, e2)					-> <lib-java-bin-exp(err)>(e, e1, e2, "eq")	
	exp-to-java-stm(err): e@Inequal(e1, e2)				-> <lib-java-bin-exp(err)>(e, e1, e2, "neq")	
	exp-to-java-stm(err): e@And(e1, e2)						-> <lib-java-bin-exp(err)>(e, e1, e2, "and")
	exp-to-java-stm(err): e@Or(e1, e2)						-> <lib-java-bin-exp(err)>(e, e1, e2, "or")
	exp-to-java-stm(err): e@TernaryConditional(e1,e2,e3)-><lib-java-ter-exp(err)>(e, e1, e2, e3, "conditional")

rules // aggregations
	
	exp-to-java-stm(err): e@Max(e1)								-> <lib-java-un-exp(err)>(e, e1, "max")
	exp-to-java-stm(err): e@Min(e1)								-> <lib-java-un-exp(err)>(e, e1, "min")
	exp-to-java-stm(err): e@Avg(e1)								-> <lib-java-un-exp(err)>(e, e1, "avg")
	exp-to-java-stm(err): e@Sum(e1)								-> <lib-java-un-exp(err)>(e, e1, "sum")
	exp-to-java-stm(err): e@Concat(e1)						-> <lib-java-un-exp(err)>(e, e1, "concat")
	exp-to-java-stm(err): e@Count(e1)							-> <lib-java-un-exp(err)>(e, e1, "count")

rules // multiplicities
	
	exp-to-java-stm(err): e@Merge(e1, e2)					-> <lib-java-bin-exp(err)>(e, e1, e2, "merge")
	exp-to-java-stm(err): e@ChoiceLeft(e1, e2)		-> <lib-java-bin-exp(err)>(e, e1, e2, "choice")

rules // literals
	
  exp-to-java-stm(err): String(value) 				-> ([], Lit(String([Chars(value)])))
  exp-to-java-stm(err): Int(value) 						-> ([], Lit(Deci(value)))
  exp-to-java-stm(err): True() 								-> ([], Lit(True()))
  exp-to-java-stm(err): False() 							-> ([], Lit(False()))

rules // lib expression calls
	
	lib-java-un-exp(err): (e, e1, x_method) -> (stms, exp)
		with
			(exp1s*, exp1j) := <exp-to-java-stm(err)>e1;
			e-ty := <java-type>e;
			x_var := <newname>"var"
		with
			stms := bstm*|[
				~exp1s*
				~e-ty x_var = Expressions.x_method(~exp1j);
			]|;
			exp := expr |[x_var]|
		
	lib-java-bin-exp(err): (e, e1, e2, x_method) -> (stms, exp)
		with
			(exp1s*, exp1j) := <exp-to-java-stm(err)>e1;
			(exp2s*, exp2j) := <exp-to-java-stm(err)>e2;
			e-ty := <java-type>e;
			x_var := <newname>"var"
		with
			stms := bstm*|[
				~exp1s*
				~exp2s*
				~e-ty x_var = Expressions.x_method(~exp1j, ~exp2j);
			]|;
			exp := expr |[x_var]|
	
	lib-java-ter-exp(err): (e, e1, e2, e3, x_method) -> (stms, exp)
		with
			(exp1s*, exp1j) := <exp-to-java-stm(err)>e1;
			(exp2s*, exp2j) := <exp-to-java-stm(err)>e2;
			(exp3s*, exp3j) := <exp-to-java-stm(err)>e3;
			e-ty := <java-type>e;
			x_var := <newname>"var"
		with
			stms := bstm*|[
				~exp1s*
				~exp2s*
				~exp3s*
				~e-ty x_var = Expressions.x_method(~exp1j, ~exp2j, ~exp3j);
			]|;
			exp := expr |[x_var]|

rules

  exp-to-java-stm(err): a -> (a', a')
	where
	  a' := <err>$[No exp-to-java-stm defined for [<get-constructor> a]/[<get-arguments;length> a].]

