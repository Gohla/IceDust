module trans/generating/expressions

imports

	include/Relations
	lib/java/Java

	trans/generating/expressions-navigators
	trans/generating/expressions-references

rules
  
  
//   emit-java-class:
//     x_name -> 
//       |[
//         package x_name;
//         
//         public class x_name implements x_name {
// 
//           ~body_fdec
//           
//           ~body_mdec
//           
//         }
//       ]|
//     with
//       body_fdec := <emit-java-field>;
//       body_mdec := <emit-java-method>
//     
//   
//   emit-java-field =
//     ! class-body-dec |[ private final String id = "1234"; ]|
//   
//   emit-java-method =
//     bstm* := <generate-my-body> "" ; 
//     !|[
//       public void foobar() {
//         bstm*
//       }
//     ]|
//   
//   generate-my-body = ! [ stm |[ throw new RuntimeException(); ]|, stm |[ throw new RuntimeException(); ]| ]

rules
	
	exp-to-java(err) = nav-to-java(err)
	exp-to-java(err) = ref-to-java(err)

rules // math

	exp-to-java(err): Addition(e1, e2)			-> <lib-java-bin-exp(err)>(e1, e2, "plus")
	exp-to-java(err): Subtraction(e1, e2)		-> <lib-java-bin-exp(err)>(e1, e2, "minus")
	exp-to-java(err): Division(e1, e2) 			-> <lib-java-bin-exp(err)>(e1, e2, "div")
	exp-to-java(err): Modulo(e1, e2) 				-> <lib-java-bin-exp(err)>(e1, e2, "mod")
	exp-to-java(err): Multiplication(e1, e2)-> <lib-java-bin-exp(err)>(e1, e2, "mul")

rules // logic
	
	exp-to-java(err): Not(e)								-> <lib-java-un-exp(err)>(e, "not")
	exp-to-java(err): LessThan(e1, e2)			-> <lib-java-bin-exp(err)>(e1, e2, "lt")	
	exp-to-java(err): LessThanEqual(e1, e2)	-> <lib-java-bin-exp(err)>(e1, e2, "lte")	
	exp-to-java(err): GreaterThan(e1, e2)		-> <lib-java-bin-exp(err)>(e1, e2, "gt")	
	exp-to-java(err): GreaterThanEqual(e1,e2)-><lib-java-bin-exp(err)>(e1, e2, "gte")	
	exp-to-java(err): Equal(e1, e2)					-> <lib-java-bin-exp(err)>(e1, e2, "eq")	
	exp-to-java(err): Inequal(e1, e2)				-> <lib-java-bin-exp(err)>(e1, e2, "neq")	
	exp-to-java(err): And(e1, e2)						-> <lib-java-bin-exp(err)>(e1, e2, "and")
	exp-to-java(err): Or(e1, e2)						-> <lib-java-bin-exp(err)>(e1, e2, "or")
	exp-to-java(err): TernaryConditional(e1,e2,e3)-><lib-java-ter-exp(err)>(e1, e2, e3, "conditional")

rules // aggregations
	
	exp-to-java(err): Max(e)								-> <lib-java-un-exp(err)>(e, "max")
	exp-to-java(err): Min(e)								-> <lib-java-un-exp(err)>(e, "min")
	exp-to-java(err): Avg(e)								-> <lib-java-un-exp(err)>(e, "avg")
	exp-to-java(err): Sum(e)								-> <lib-java-un-exp(err)>(e, "sum")
	exp-to-java(err): Concat(e)							-> <lib-java-un-exp(err)>(e, "concat")
	exp-to-java(err): Count(e)							-> <lib-java-un-exp(err)>(e, "count")

rules // multiplicities
	
	exp-to-java(err): Merge(e1, e2)					-> <lib-java-bin-exp(err)>(e1, e2, "merge")
	exp-to-java(err): ChoiceLeft(e1, e2)		-> <lib-java-bin-exp(err)>(e1, e2, "choice")

rules // literals
	
  exp-to-java(err): String(value) 				-> Lit(String([Chars(value)]))
  exp-to-java(err): Int(value) 						-> Lit(Deci(value))
  exp-to-java(err): True() 								-> Lit(True())
  exp-to-java(err): False() 							-> Lit(False())

rules // lib expression calls
	
	lib-java-un-exp(err): (exp, lib-call) ->
		Invoke(
		   Method(MethodName(AmbName(Id("Expressions")), Id(lib-call)))
		 , [<exp-to-java(err)>exp]
		 )
	
	lib-java-bin-exp(err): (exp1, exp2, lib-call) ->
		Invoke(
		   Method(MethodName(AmbName(Id("Expressions")), Id(lib-call)))
		 , [<exp-to-java(err)>exp1,
		    <exp-to-java(err)>exp2]
		 )
		 
	lib-java-ter-exp(err): (exp1, exp2, exp3, lib-call) ->
		Invoke(
		   Method(MethodName(AmbName(Id("Expressions")), Id(lib-call)))
		 , [<exp-to-java(err)>exp1,
		    <exp-to-java(err)>exp2,
		    <exp-to-java(err)>exp3]
		 )
		 
rules
	
  exp-to-java(err): a -> a'
	where
	  a' := <err>$[No exp-to-java defined for [<get-constructor> a]/[<get-arguments;length> a].]
