module trans/generating/generate

imports

	lib/editor-common.generated
	lib/java/Java
	lib/java/pretty-print
	lib/index/-
	lib/nabl/-
	lib/task/-
	
	include/Relations
	editor/Relations-Outliner

	trans/desugaring/desugar
	trans/naming/names
	trans/naming/properties


rules // Builders
	
	generate-java:
		(selected, position, ast, path, project-path) -> (fileName, result)
		with
			index-setup(|<language>, project-path);
			task-setup(|project-path);
			(fileName, result) := <generate-java>(selected, path)
			
	compile-java:
		(selected, position, ast, path, project-path) -> None()
		with
			index-setup(|<language>, project-path);
			task-setup(|project-path);
			(javaFileName, _) := <generate-java>(selected, path);
			<compile-java> javaFileName
			
	execute-java:
		(selected, position, ast, path, project-path) -> None()
		with
			index-setup(|<language>, project-path);
			task-setup(|project-path);
			(javaFileName, _) := <generate-java>(selected, path);
			classFileName := <compile-java> javaFileName;
			<execute-java> classFileName
			

	generate-java:
	    (selected, path) -> (fileName, result)
	    with
			fileName := <guarantee-extension(|"java")> path;
			java-ast := <to-java> selected;
			result   := <pp-java-string> java-ast;
			<write-file> (fileName, result)
			
	compile-java:
		javaFileName -> classFileName
		with
			<try(call)> ("javac", [javaFileName]);
			classFileName := <guarantee-extension(|"class")> javaFileName;
			<refresh-workspace-file> classFileName

	execute-java:
		classFileName -> None()
		with
			classPath := <dirname>classFileName;
			className := <base-filename;remove-extension> classFileName;
			<try(call)> ("java", ["-cp", classPath, className])
			


rules // Helper rules : file writer

	write-file: (fileName, content) -> (fileName, content)
		where
			<dirname;ensure-dir> fileName
		where
			fileDescriptor := <fopen> (fileName, "w");
			<fputs> (content, fileDescriptor);
			<fclose> fileDescriptor;
			<refresh-workspace-file> fileName
			
	ensure-dir: path -> path
		where
			<file-exists;filemode;isdir> path
	ensure-dir: path -> path
		where
			<not(file-exists;filemode;isdir)> path;
			<dirname;ensure-dir> path;
			<mkdir> path



rules // Transformation to java ast.

  to-java:
    [_] -> <concat-strings> <map(to-java)>
    
  to-java:
    () -> ""
    
  to-java:
  	None() -> ""

  to-java: Module(_,_,_,_) -> <fail>
  	where
  		err-msg(|"Desugar before generating code.")
  		// ; with(fail|"Desugar before generating code.")


// Module
  to-java:
    ModuleDesugared(moduleName, model, data, execute) ->
CompilationUnit(
  None()
, [ TypeImportDec(
      TypeName(
        PackageOrTypeName(PackageOrTypeName(Id("java")), Id("util"))
      , Id("Collection")
      )
    )
  , TypeImportDec(
      TypeName(
        PackageOrTypeName(PackageOrTypeName(Id("java")), Id("util"))
      , Id("HashSet")
      )
    )
  ]
, <concat>[[ mainClass ], modelJava]
)
	where
		mainClass := <main-class-to-java>ModuleDesugared(moduleName, model, data, execute);
		modelJava := <to-java>model
		
  main-class-to-java: ModuleDesugared(moduleName, model, data, execute) ->
	  ClassDec(
	      ClassDecHead([], Id(moduleName), None(), None(), None())
	    , ClassBody(
	        [ MethodDec(
	            MethodDecHead(
	              [Public(), Static()]
	            , None()
	            , Void()
	            , Id("main")
	            , [ Param(
	                  []
	                , ArrayType(ClassOrInterfaceType(TypeName(Id("String")), None()))
	                , Id("args")
	                )
	              ]
	            , None()
	            )
	          , Block(
	           	<concat>[
	              dataJava,
	              executeJava
	              ]
	            )
	          ),
	          <to-collection>
	        ]
	      )
	    )
	where
		dataJava := <to-java>data;
		if Executable(_) := execute then
			executeJava := <to-java>execute
		else
			executeJava := []
		end


// Model
  to-java: ModelDef(model) -> <map(try(to-java))>model

  to-java: EntityTypeDef(_, name, attributesAndRoles) -> 
	  ClassDec(
	      ClassDecHead([], Id(name), None(), None(), None())
	    , ClassBody(
	      	<concat>[[ConstrDec(
	            ConstrDecHead([Public()], None(), Id(name), [], None())
	          , ConstrBody(
	              None()
	            , fulfillRolesJavaInit
	            )
	          )],
	      		attributesAndRolesJava,
	      		fulfillRolesJava	
	      	]
	      )
	    )
	where
		attributesAndRolesJava := <map(to-java(|name));concat>attributesAndRoles;
		fulfillRoles := <get-fulfill-role-multiple>name;
		fulfillRolesJava := <map(to-java-fullfil-role) <+ empty-list> fulfillRoles;
		fulfillRolesJavaInit := <map(to-java-fulfill-role-init) <+ empty-list> fulfillRoles
	
	empty-list: _ -> []
	
	to-java-fullfil-role: fulfillRole@_ ->
			FieldDec(
        [Public()]
      , ClassOrInterfaceType(
          TypeName(Id("Collection"))
        , Some(TypeArgs([ClassOrInterfaceType(TypeName(Id(relationName)), None())]))
        )
      , [VarDec(Id($[[relationName]_[roleName]]))]
      )
		where
			relationName := <de-def;nabl-uri-parent;nabl-uri-name>fulfillRole;
			roleName := <de-def;nabl-uri-name>fulfillRole
			
	to-java-fulfill-role-init: fulfillRole@_ ->
			ExprStm(
	      Assign(
	        ExprName(Id($[[relationName]_[roleName]]))
	      , NewInstance(
	          None()
	        , ClassOrInterfaceType(
	            TypeName(Id("HashSet"))
	          , Some(TypeArgs([ClassOrInterfaceType(TypeName(Id($[[relationName]])), None())]))
	          )
	        , []
	        , None()
	        )
	      )
	    )
		where
			relationName := <de-def;nabl-uri-parent;nabl-uri-name>fulfillRole;
			roleName := <de-def;nabl-uri-name>fulfillRole

	de-def: Def(x) -> x

  to-java(|entityName): Attribute(name, PrimitiveType(type), derivation) ->
		[ field
	    , setter
	    , MethodDec(
	        MethodDecHead(
	          [Public()]
	        , None()
	        , ClassOrInterfaceType(TypeName(Id(javaType)), None())
	        , Id($[get_[name]])
	        , []
	        , None()
	        )
	      , Block(
	        	[Return(Some(getterExpr))]
	        )
	      )
	     ]
		where
			javaType := <to-java>type;
			derivationType := <get-derivation-type <+ err-msg(|$[Could not get derivation type of Attribute.])>name;
			if Normal() := derivationType then
				field := <field>(name, javaType);
				setter := <setter>(name, javaType);
				getterExpr := ExprName(Id(name))
			else if DefaultValue() := derivationType then
				field := <field>(name, javaType);
				setter := <setter>(name, javaType);
				Derivation(derivationExpr, _) := derivation;
				getterExpr := Cond(
	                      NotEq(ExprName(Id(name)), <null-value>type)
	                    , ExprName(Id(name))
	                    , <to-java>derivationExpr
	                    )
			else if Derivation() := derivationType then
				field := [];
				setter := [];
				Derivation(derivationExpr, _) := derivation;
				getterExpr := <to-java>derivationExpr
			end end end
	
	field: (name, javaType) ->
				FieldDec(
	        [Private()]
	      , ClassOrInterfaceType(TypeName(Id(javaType)), None())
	      , [VarDec(Id(name))]
	      )
	
	setter: (name, javaType) ->
		MethodDec(
      MethodDecHead(
        [Public()]
      , None()
      , Void()
      , Id($[set_[name]])
      , [Param(
           []
         , ClassOrInterfaceType(TypeName(Id(javaType)), None())
         , Id(name)
         )]
      , None()
      )
    , Block(
        [ExprStm(
           Assign(Field(This(), Id(name)), ExprName(Id(name)))
         )]
      )
    )

  to-java(|relationName): Role(EntityType(type), multiplicity, roleName) ->
		[	FieldDec(
	      [Public()]
	    , ClassOrInterfaceType(TypeName(Id(type)), None())
	    , [VarDec(Id(roleName))]
	    )
    , MethodDec(
        MethodDecHead(
          [Public(), Static()]
        , None()
        , ClassOrInterfaceType(
            TypeName(Id("Collection"))
          , Some(TypeArgs([ClassOrInterfaceType(TypeName(Id(relationName)), None())]))
          )
        , Id($[[roleName]_in])
        , [ Param(
              []
            , ClassOrInterfaceType(
                TypeName(Id("Collection"))
              , Some(TypeArgs([ClassOrInterfaceType(TypeName(Id(type)), None())]))
              )
            , Id("in")
            )
          ]
        , None()
        )
      , Block(
          [ LocalVarDecStm(
              LocalVarDec(
                []
              , ClassOrInterfaceType(
                  TypeName(Id("Collection"))
                , Some(TypeArgs([ClassOrInterfaceType(TypeName(Id(relationName)), None())]))
                )
              , [ VarDec(
                    Id("result")
                  , NewInstance(
                      None()
                    , ClassOrInterfaceType(
                        TypeName(Id("HashSet"))
                      , Some(TypeArgs([ClassOrInterfaceType(TypeName(Id(relationName)), None())]))
                      )
                    , []
                    , None()
                    )
                  )
                ]
              )
            )
          , ForEach(
              Param(
                []
              , ClassOrInterfaceType(TypeName(Id(type)), None())
              , Id("elem")
              )
            , ExprName(Id("in"))
            , Block(
                [ ExprStm(
                    Invoke(
                      Method(MethodName(AmbName(Id("result")), Id("addAll")))
                    , [ExprName(AmbName(Id("elem")), Id($[[relationName]_[roleName]]))]
                    )
                  )
                ]
              )
            )
          , Return(Some(ExprName(Id("result"))))
          ]
        )
      )
    , MethodDec(
        MethodDecHead(
          [Public(), Static()]
        , None()
        , ClassOrInterfaceType(
            TypeName(Id("Collection"))
          , Some(TypeArgs([ClassOrInterfaceType(TypeName(Id(type)), None())]))
          )
        , Id($[[roleName]_out])
        , [ Param(
              []
            , ClassOrInterfaceType(
                TypeName(Id("Collection"))
              , Some(TypeArgs([ClassOrInterfaceType(TypeName(Id(relationName)), None())]))
              )
            , Id("out")
            )
          ]
        , None()
        )
      , Block(
          [ LocalVarDecStm(
              LocalVarDec(
                []
              , ClassOrInterfaceType(
                  TypeName(Id("Collection"))
                , Some(TypeArgs([ClassOrInterfaceType(TypeName(Id(type)), None())]))
                )
              , [ VarDec(
                    Id("result")
                  , NewInstance(
                      None()
                    , ClassOrInterfaceType(
                        TypeName(Id("HashSet"))
                      , Some(TypeArgs([ClassOrInterfaceType(TypeName(Id(type)), None())]))
                      )
                    , []
                    , None()
                    )
                  )
                ]
              )
            )
          , ForEach(
              Param(
                []
              , ClassOrInterfaceType(TypeName(Id(relationName)), None())
              , Id("u")
              )
            , ExprName(Id("out"))
            , Block(
                [ ExprStm(
                    Invoke(
                      Method(MethodName(AmbName(Id("result")), Id("add")))
                    , [ExprName(AmbName(Id("u")), Id(roleName))]
                    )
                  )
                ]
              )
            )
          , Return(Some(ExprName(Id("result"))))
          ]
        )
      )
		]
				

  to-java: "String" -> "String"
  to-java: "Int"	-> "int"

	to-java: AttributeName(name) -> Invoke(Method(MethodName(Id($[get_[name]]))), [])
	
	null-value: "String" -> Lit(Null())
	null-value: "Int" -> Lit(Deci("0"))

// Data
  to-java: DataDef(defs) -> <map(to-java);concat> defs
  
  to-java: EntityOrRelation(
        EntityType(entityType)
      , entityName
      , roleValues
      , attributeValues
      )
      ->
      <concat>[[
      LocalVarDecStm(
          LocalVarDec(
            []
          , ClassOrInterfaceType(TypeName(Id(entityType)), None())
          , [ VarDec(
                Id(entityName)
              , NewInstance(
                  None()
                , ClassOrInterfaceType(TypeName(Id(entityType)), None())
                , []
                , None()
                )
              )
            ]
          )
        )],
        attributeValuesJava,
        roleValuesJava
        ]
	where
		attributeValuesJava := <map(to-java(|entityName))> attributeValues;
		roleValuesJava			:= <map(to-java(|entityName, entityType));concat> roleValues

  to-java(|entityName) : AttributeValue(AttributeName(attributeName), attributeValue) ->
	  	ExprStm(
        Invoke(
          Method(MethodName(AmbName(Id(entityName)), Id($[set_[attributeName]])))
        , [attributeValueJava]
        )
	    )
    where
    	attributeValueJava := <to-java>attributeValue
    	
  to-java(|entityName, entityType) :
  	RoleValue(RoleName(roleName), EntityName(otherEntityName)) ->
  	[	
  		ExprStm(
		      Assign(
		        ExprName(AmbName(Id(entityName)), Id(roleName))
		      , ExprName(Id(otherEntityName))
		      )
		    )
		  , ExprStm(
		      Invoke(
		        Method(
		          MethodName(
		            AmbName(AmbName(Id(otherEntityName)), Id($[[entityType]_[roleName]]))
		          , Id("add")
		          )
		        )
		      , [ExprName(Id(entityName))]
		      )
		    )
		 ]
  

  to-java: String(value) -> Lit(String([Chars(value)]))
  to-java: Integer(value) -> Lit(Deci(value))


// Execute
  to-java: Executable(executes) -> <map(to-java;syso)>executes
  
  to-java: AccessEntityAttribute(EntityName(entityName), attributeName) ->
		Invoke(
       Method(MethodName(AmbName(Id(entityName)), Id($[get_[attributeName]])))
     , []
     )

	to-java: NavigateIn(prevNav, _, RoleName(roleInName), EntityType(relationName)) ->
		Invoke(
      Method(MethodName(AmbName(Id(relationName)), Id($[[roleInName]_in])))
    , [<to-java>prevNav]
    )
  
  to-java: NavigateOut(prevNav, _, EntityType(relationName), RoleName(roleOutName)) ->
		Invoke(
		  Method(MethodName(AmbName(Id(relationName)), Id($[[roleOutName]_out])))
		, [ <to-java>prevNav ]
		)
		
	to-java: EntityName(entityName) -> 
		Invoke(
		   Method(MethodName(Id("toCollection")))
		 , [ExprName(Id(entityName))]
		 )
		 
	syso: javaExpr ->
		ExprStm(
		  Invoke(
		    Method(
		      MethodName(
		        AmbName(AmbName(Id("System")), Id("out"))
		      , Id("println")
		      )
		    )
		  , [ javaExpr ]
		  )
		)


// Expressions
	to-java: BinExp(Plus(), exp1, exp2)		-> Plus(	<to-java>exp1, <to-java>exp2)
	to-java: BinExp(Minus(), exp1, exp2)	-> Minus(	<to-java>exp1, <to-java>exp2)
	to-java: BinExp(Div(), exp1, exp2)		-> Div(		<to-java>exp1, <to-java>exp2)
	to-java: BinExp(Mod(), exp1, exp2)		-> Remain(<to-java>exp1, <to-java>exp2)
	to-java: BinExp(Mul(), exp1, exp2)		-> Mul(		<to-java>exp1, <to-java>exp2)


// Debugging	          
  to-java: a -> []
  	where
		  warn-msg(|$[No to-java defined for [<get-constructor> a]/[<get-arguments;length> a].])


// Runtime (TODO: move this to plain java files?)
	to-collection: _ ->
	MethodDec(
    MethodDecHead(
      [Public(), Static()]
    , Some(TypeParams([TypeParam(Id("E"), None())]))
    , ClassOrInterfaceType(
        TypeName(Id("Collection"))
      , Some(TypeArgs([ClassOrInterfaceType(TypeName(Id("E")), None())]))
      )
    , Id("toCollection")
    , [Param(
         []
       , ClassOrInterfaceType(TypeName(Id("E")), None())
       , Id("e")
       )]
    , None()
    )
  , Block(
      [ LocalVarDecStm(
          LocalVarDec(
            []
          , ClassOrInterfaceType(
              TypeName(Id("Collection"))
            , Some(TypeArgs([ClassOrInterfaceType(TypeName(Id("E")), None())]))
            )
          , [ VarDec(
                Id("collection")
              , NewInstance(
                  None()
                , ClassOrInterfaceType(
                    TypeName(Id("HashSet"))
                  , Some(TypeArgs([ClassOrInterfaceType(TypeName(Id("E")), None())]))
                  )
                , []
                , None()
                )
              )
            ]
          )
        )
      , ExprStm(
          Invoke(
            Method(MethodName(AmbName(Id("collection")), Id("add")))
          , [ExprName(Id("e"))]
          )
        )
      , Return(Some(ExprName(Id("collection"))))
      ]
    )
  )