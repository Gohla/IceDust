module trans/generating/java/expressions

imports // constructors

  lib/java/Java
  src-gen/signatures/Expressions-sig

imports // functions

  trans/api/_runtime
  trans/generating/_ir/expressions
  trans/generating/java/expressions-references
  trans/generating/java/types
  trans/lib/lists-tuples
  trans/lib/string
  trans/lib/traverse
  trans/naming/names

rules // lib expression calls  // (rel-expr, int) -> (java-stm*, java-expr)
  
  exp-to-java-stm(err|i): e ->
    (
      bstm*|[
        ~args-stms*
        refty x_var = Expressions.x_methodpostfix(~arg-exps*);
      ]|,
      expr |[x_var]|
    )
  where
    lib-call
  with
    arg*                    := <get-arguments>e;
    (arg-java, l)           := <map-fold(arg-to-java-stm(err))>(arg*, i);
    (args-stms*, arg-exps*) := <unzip;(flatten-list,id)>arg-java;
    refty                   := <java-type>e;
    x_var                   := $[var[<inc>l]];
    x_methodpostfix         := <lib-method-name>e

rules // (rel-expr, int) -> ((java-stm*, java-expr), int)

  arg-to-java-stm(err) : (e, i) -> ((stms, exp), i')
    with
      (stms, exp) := <exp-to-java-stm(err|i)>e;
      i' := <add>(i, <length>stms)

rules // literals
  
  exp-to-java-stm(err|i): String(value)         -> ([], Lit(String([Chars(value)])))
  exp-to-java-stm(err|i): Int(value)            -> ([], Lit(Deci(value)))
  exp-to-java-stm(err|i): Float(value)          -> ([], Lit(Float($[[value]f])))
  exp-to-java-stm(err|i): True()                -> ([], Lit(True()))
  exp-to-java-stm(err|i): False()               -> ([], Lit(False()))
  exp-to-java-stm(err|i): Datetime(value)       -> ([], expr |[Expressions.parseDatetime(e1)]|) with e1 := Lit(String([Chars(value)]))
  exp-to-java-stm(err|i): NoValue()             -> ([], expr |[null]|)

rules // casts
  
  exp-to-java-stm(err|i): e@Cast(NoValue(), e1-ty) -> ([], expr |[(x)null]|) with x := <java-id>e1-ty
  
  exp-to-java-stm(err|i): e@Cast(e1, e1-ty) -> (stms, exp)
    with
      (exp1s*, exp1j) := <exp-to-java-stm(err|i)>e1;
      j := <add>(i, <length>exp1s*);
      refty := <java-type>e;
      x_var := $[var[<inc>j]];
      x_method := $[as[<java-id>e1-ty]]
    with
      stms := bstm*|[
        ~exp1s*
        refty x_var = Expressions.x_method(~exp1j);
      ]|;
      exp := expr |[x_var]|

rules

  exp-to-java-stm(err|i): a -> (a', a')
  where
    a' := <err>$[No exp-to-java-stm defined for [<get-constructor> a]/[<get-arguments;length> a].]

