module trans/generating/java/expressions

imports // constructors

  lib/java/Java
  src-gen/signatures/Expressions-sig

imports // functions

  trans/api/_runtime
  trans/generating/java/expressions-references
  trans/generating/java/types
  trans/naming/names

rules // math

  lib-call-postfix-type:     Addition(_, _)         ->"plus"
  lib-call-postfix-type:     Subtraction(_, _)      ->"minus"
  lib-call-postfix-type:     Division(_, _)         ->"div"
  lib-call-postfix-type:     Modulo(_, _)           ->"mod"
  lib-call-postfix-type:     Multiplication(_, _)   ->"mul"

rules // logic
  
  lib-call-postfix-type:     Not(_)                 ->"not"
  lib-call-postfix-type:     LessThan(_, _)         ->"lt"
  lib-call-postfix-type:     LessThanEqual(_, _)    ->"lte"
  lib-call-postfix-type:     GreaterThan(_, _)      ->"gt"
  lib-call-postfix-type:     GreaterThanEqual(_,_)  ->"gte"
  lib-call-postfix-mults:    Equal(_, _)            ->"eq"
  lib-call-postfix-mults:    Inequal(_, _)          ->"neq"
  lib-call:                  And(_, _)              ->"and"
  lib-call:                  Or(_, _)               ->"or"
  lib-call-postfix-mults:    TernaryConditional(_,_,_) ->"conditional"

rules // aggregations
  
  lib-call-postfix-type:     Max(_)                 ->"max"
  lib-call-postfix-type:     Min(_)                 ->"min"
  lib-call-postfix-type:     Avg(_)                 ->"avg"
  lib-call-postfix-type:     Sum(_)                 ->"sum"
  lib-call:                  Conj(_)                ->"conj"
  lib-call:                  Disj(_)                ->"disj"
  lib-call:                  Concat(_)              ->"concat"
  lib-call:                  Count(_)               ->"count"

rules // multiplicities
  
  lib-call-postfix-mults:    Merge(_, _)            ->"merge"
  lib-call-postfix-mults:    ChoiceLeft(_, _)       ->"choice"

rules // lib expression calls  
      
  exp-to-java-stm(err|i): e -> (stms, exp)
    where
      x_method := <lib-call>e;
      [e1] := <get-arguments>e
    with
      (exp1s*, exp1j) := <exp-to-java-stm(err|i)>e1;
      j := <add>(i, <length>exp1s*);
      refty := <java-type>e;
      x_var := $[var[<inc>j]]
    with
      stms := bstm*|[
        ~exp1s*
        refty x_var = Expressions.x_method(~exp1j);
      ]|;
      exp := expr |[x_var]|
  
  exp-to-java-stm(err|i): e -> (stms, exp)
    where
      x_method := <lib-call-postfix-type>e;
      [e1] := <get-arguments>e
    with
      (exp1s*, exp1j) := <exp-to-java-stm(err|i)>e1;
      j := <add>(i, <length>exp1s*);
      refty := <java-type>e;
      x_var := $[var[<inc>j]];
      x_methodpostfix := $[[x_method]_[<_get-type;java-id>e1]]
    with
      stms := bstm*|[
        ~exp1s*
        refty x_var = Expressions.x_methodpostfix(~exp1j);
      ]|;
      exp := expr |[x_var]|
    
  exp-to-java-stm(err|i): e -> (stms, exp)
    where
      x_method := <lib-call>e;
      [e1, e2] := <get-arguments>e
    with
      (exp1s*, exp1j) := <exp-to-java-stm(err|i)>e1;
      j := <add>(i, <length>exp1s*);
      (exp2s*, exp2j) := <exp-to-java-stm(err|j)>e2;
      k := <add>(j, <length>exp2s*);
      refty := <java-type>e;
      x_var := $[var[<inc>k]]
    with
      stms := bstm*|[
        ~exp1s*
        ~exp2s*
        refty x_var = Expressions.x_method(~exp1j, ~exp2j);
      ]|;
      exp := expr |[x_var]|
    
  exp-to-java-stm(err|i): e -> (stms, exp)
    where
      x_method := <lib-call-postfix-type>e;
      [e1, e2] := <get-arguments>e
    with
      (exp1s*, exp1j) := <exp-to-java-stm(err|i)>e1;
      j := <add>(i, <length>exp1s*);
      (exp2s*, exp2j) := <exp-to-java-stm(err|j)>e2;
      k := <add>(j, <length>exp2s*);
      refty := <java-type>e;
      x_var := $[var[<inc>k]];
      if <not(eq)>(<_get-type>e1, NoValue()) then
        x_methodpostfix := $[[x_method]_[<_get-type;java-id>e1]]
      else
        x_methodpostfix := $[[x_method]_[<_get-type;java-id>e2]]
      end
    with
      stms := bstm*|[
        ~exp1s*
        ~exp2s*
        refty x_var = Expressions.x_methodpostfix(~exp1j, ~exp2j);
      ]|;
      exp := expr |[x_var]|
    
  exp-to-java-stm(err|i): e -> (stms, exp)
    where
      x_method := <lib-call-postfix-mults>e;
      [e1, e2] := <get-arguments>e
    with
      (exp1s*, exp1j) := <exp-to-java-stm(err|i)>e1;
      j := <add>(i, <length>exp1s*);
      (exp2s*, exp2j) := <exp-to-java-stm(err|j)>e2;
      k := <add>(j, <length>exp2s*);
      refty := <java-type>e;
      x_var := $[var[<inc>k]];
      x_methodpostfix := $[[x_method]_[<get-multiplicity;java-id>e1]_[<get-multiplicity;java-id>e2]]
    with
      stms := bstm*|[
        ~exp1s*
        ~exp2s*
        refty x_var = Expressions.x_methodpostfix(~exp1j, ~exp2j);
      ]|;
      exp := expr |[x_var]|
  
  exp-to-java-stm(err|i): e -> (stms, exp)
    where
      x_method := <lib-call-postfix-mults>e;
      [e1, e2, e3] := <get-arguments>e
    with
      (exp1s*, exp1j) := <exp-to-java-stm(err|i)>e1;
      j := <add>(i, <length>exp1s*);
      (exp2s*, exp2j) := <exp-to-java-stm(err|j)>e2;
      k := <add>(j, <length>exp2s*);
      (exp3s*, exp3j) := <exp-to-java-stm(err|k)>e3;
      l := <add>(k, <length>exp3s*);
      refty := <java-type>e;
      x_var := $[var[<inc>l]];
      x_methodpostfix := $[[x_method]_[<get-multiplicity;java-id>e1]_[<get-multiplicity;java-id>e2]_[<get-multiplicity;java-id>e3]]
    with
      stms := bstm*|[
        ~exp1s*
        ~exp2s*
        ~exp3s*
        refty x_var = Expressions.x_methodpostfix(~exp1j, ~exp2j, ~exp3j);
      ]|;
      exp := expr |[x_var]|

rules // literals
  
  exp-to-java-stm(err|i): String(value)         -> ([], Lit(String([Chars(value)])))
  exp-to-java-stm(err|i): Int(value)             -> ([], Lit(Deci(value)))
  exp-to-java-stm(err|i): Float(value)          -> ([], Lit(Float($[[value]f])))
  exp-to-java-stm(err|i): True()                 -> ([], Lit(True()))
  exp-to-java-stm(err|i): False()               -> ([], Lit(False()))
  exp-to-java-stm(err|i): Datetime(value)       -> ([], expr |[Expressions.parseDatetime(e1)]|) with e1 := Lit(String([Chars(value)]))
  exp-to-java-stm(err|i): NoValue()             -> ([], expr |[null]|)

rules // casts
  
  exp-to-java-stm(err|i): e@Cast(NoValue(), e1-ty) -> ([], expr |[(x)null]|) with x := <java-id>e1-ty
  
  exp-to-java-stm(err|i): e@Cast(e1, e1-ty) -> (stms, exp)
    with
      (exp1s*, exp1j) := <exp-to-java-stm(err|i)>e1;
      j := <add>(i, <length>exp1s*);
      refty := <java-type>e;
      x_var := $[var[<inc>j]];
      x_method := $[as[<java-id>e1-ty]]
    with
      stms := bstm*|[
        ~exp1s*
        refty x_var = Expressions.x_method(~exp1j);
      ]|;
      exp := expr |[x_var]|

rules

  exp-to-java-stm(err|i): a -> (a', a')
  where
    a' := <err>$[No exp-to-java-stm defined for [<get-constructor> a]/[<get-arguments;length> a].]

