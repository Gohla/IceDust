module trans/generating/webdsl-eager/model

imports // constructors

	trans/api/_runtime-constructors
	trans/api/constructors
	lib/webdsl/WebDSL
	src-gen/signatures/Expressions-sig
	src-gen/signatures/Model-sig
	src-gen/signatures/Modules-sig
	trans/desugaring/constructors

imports // functions

	trans/analysis2/path
	trans/api/_runtime
	trans/api/model-api
	trans/api/model-names-api
	trans/lib/search
	trans/lib/string
	trans/lib/lists-tuples
	trans/naming/names
	trans/naming/_notNaBL
	trans/generating/webdsl/expressions
	trans/generating/webdsl/expressions-references
	trans/generating/webdsl/model
	trans/generating/webdsl/types

rules // entities
	
  to-webdsl-eager(err): x_name -> 
		webdsl |[
			entity x_name {
				ebd1*
				ebd2*
				ebd3*
				ebd4*
				ebd5*
			}
		]|
	where
		is-entityname
	with
		ebd1* := <entityname-get-attributenames;map(to-webdsl-eager(err))>x_name;
		ebd2* := <entityname-get-rolenames;     map(to-webdsl(err))>x_name;
		ebd3* := <entityname-get-inversenames;  map(to-webdsl(err))>x_name;
		ebd4* := <entityname-get-attributenames;filter(to-webdsl-eager-trigger-dirty(err))>x_name;
		ebd5* := <entityname-get-rolenames;     filter(to-webdsl-eager-trigger-dirty(err))>x_name

rules // attributes
	

	to-webdsl-eager(err): x_name -> webdsl |[
		x_name : srt1 (default=null)
		
    static function x_getter(entity:x_entity):srt1{
    	return if (entity!=null) entity.x_name else null;
    }
    
    static function x_getter(entities:[x_entity]):[srt1]{
    	var r : [srt1];
	  	for(entity in entities){
	  		r.add(entity.x_name);
	  	}
	  	return r;
    }
	]|
		where
			is-attributename
		where
			attributename-is-normal
		with
			srt1     := <_get-type;type-to-webdsl(err)>x_name;
			x_getter := $[get_[x_name]];
			x_entity := <attributename-get-entityname>x_name
			
	to-webdsl-eager(err): x_name -> webdsl |[
		x_name : srt1 (default=x_calc())
		
    function x_calc() : srt1{
    	return e1;
    }
    
    function x_update() {
    	x_name := x_calc();
    }
    
    static function x_update(entity : x_entity){
    	entity.x_update();
    }
    
    static function x_update(entities : {x_entity}){
    	for(entity in entities){
    		entity.x_update();
    	}
    }
    
    static function x_dirty () : Set<x_entity> {
    	return x_sdirty;
    }
    
    static function x_dirtyb () : Bool {
    	return x_entity.x_dirty().length!=0;
    }
    
    static function x_clean () {
    	x_sdirty := Set<x_entity>();
    }
    
    static function x_updatec () {
    	var values := x_entity.x_dirty();
      if(values.length!=0){
      	log("Updating "+e2+": "+values.length);
      }
    	x_entity.x_clean();
    	x_entity.x_update(values);
    }
		
    static function x_getter(entity:x_entity):srt1{
    	return if(entity!=null) entity.x_name else null;
    }
    
    static function x_getter(entities:[x_entity]):[srt1]{
    	var r : [srt1];
	  	for(entity in entities){
	  		if(entity.x_name!=null){
	  			r.add(entity.x_name);
	  		}
	  	}
	  	return r;
    }
	]|
		where
			is-attributename
		where
			attributename-is-derivation <+ attributename-is-default
		with
			srt1     := <_get-type;type-to-webdsl(err)>x_name;
			e1       := <attributename-get-expr;to-webdsl(err)>x_name;
			x_getter := $[get_[x_name]];
			x_entity := <attributename-get-entityname>x_name;
			x_calc   := $[calculate_[x_name]];
			x_update := $[update_[x_name]];
			x_sdirty := $[[x_entity]_[x_name]_dirty];
			x_dirty  := $[[x_name]_dirty];
			x_dirtyb := $[[x_name]_has_dirty];
			x_clean  := $[[x_name]_dirty_clean];
			x_updatec:= $[[x_name]_update_clean];
			e2       := String($[[x_entity].[x_name]])

rules // attributes - trigger dirty
			
	to-webdsl-eager-trigger-dirty(err): x_name -> webdsl |[
    extend function x_set(newValue:srt1){
    	if(x_name != newValue){
    		stat1*
    	}
    }
	]|
		where
			is-attributename
		where
			flowsToPaths := <name-get-flowsto-paths;list-not-empty>x_name
		with
			srt1   := <_get-type;type-to-webdsl(err)>x_name;
			x_set  := $[set[<ucfirst>x_name]];
			stat1* := <map(ttuple(path-get-last, path-remove-end;path-to-expr);flagdirty-webdslstat(err))>flowsToPaths

rules // roles - trigger dirty

	to-webdsl-eager-trigger-dirty(err): x_name -> webdsl |[
    extend function x_set(newValue:srt1){
    	if(x_name != newValue){
	    	stat1*
	    	stat2*
	    	stat3*
    	}
    }
	]|
		where
			is-rolename
		where
			flowsToPaths := <name-get-flowsto-paths;list-not-empty>x_name
		with
			newValueExpr := Ref("newValue"){(NablProp_multiplicity(), <get-multiplicity>x_name), (Type(), <_get-type>x_name)};
			srt1   := <_get-type;type-to-webdsl(err)>x_name;
			x_set  := $[set[<ucfirst>x_name]];
			stat1* := <filter(path-origin-is-inverse);map(                   ttuple(path-get-last, path-remove-end;path-to-expr               );flagdirty-webdslstat(err))>flowsToPaths;
			stat2* := <filter(path-origin-is-role)   ;map(path-prependorigin;ttuple(path-get-last, path-remove-end;path-to-expr               );flagdirty-webdslstat(err))>flowsToPaths;
			stat3* := <filter(path-origin-is-role)   ;map(                   ttuple(path-get-last, path-remove-end;path-to-expr(|newValueExpr));flagdirty-webdslstat(err))>flowsToPaths

rules // helper
	
	flagdirty-webdslstat(err): (attrName, expr) -> webdsl |[
		if(e1 != null){
			log("Attribute " + e2 + " is dirty of " + e1);
			x_dirty.add(e1);
		}
	]|
		where
			<get-multiplicity;upper-one>expr
		with
			e1      := <to-webdsl(err)>expr;
			e2      := String(attrName);
			x_dirty := $[[<attributename-get-entityname>attrName]_[attrName]_dirty]
	
	flagdirty-webdslstat(err): (attrName, expr) -> webdsl |[
		log("Attribute " + e2 + " is dirty of " + e1);
		x_dirty.addAll(e1);
	]|
		where
			<get-multiplicity;upper-many>expr
		with
			e1      := <to-webdsl(err)>expr;
			e2      := String(attrName);
			x_dirty := $[[<attributename-get-entityname>attrName]_[attrName]_dirty]
