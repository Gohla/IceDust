module generating/webdsl-eager/model

imports // constructors

	api/_runtime-constructors
	api/constructors
	webdsl/WebDSL
	signatures/Expressions-sig
	signatures/Model-sig
	signatures/Modules-sig
	desugaring/constructors

imports // functions

	analysis2/path
	api/_runtime
	api/model-api
	api/model-names-api
	lib/search
	lib/string
	lib/lists-tuples
  names/naming/names
	naming/_notNaBL
	generating/webdsl/expressions
	generating/webdsl/expressions-references
	generating/webdsl/model
	generating/webdsl/types

rules // entities
	
  to-webdsl-eager(err): x_name -> 
		webdsl |[
			entity x_name {
				ebd1*
				ebd2*
				ebd3*
				ebd4*
				ebd5*
			}
		]|
	where
		is-entityname
	with
		ebd1* := <entityname-get-attributenames;map(to-webdsl-eager(err))>x_name;
		ebd2* := <entityname-get-rolenames;     map(to-webdsl(err))>x_name;
		ebd3* := <entityname-get-inversenames;  map(to-webdsl(err))>x_name;
		ebd4* := <entityname-get-attributenames;filter(to-webdsl-eager-trigger-dirty(err);flatten-list)>x_name;
		ebd5* := <entityname-get-rolenames;     filter(to-webdsl-eager-trigger-dirty(err))>x_name

rules // attributes: normal

	to-webdsl-eager(err): x_name -> webdsl |[
		x_name : srt1 (default=null)
		
    static function x_getter(en: x_entity) : srt1 {
      return if(en == null) null as srt1 else en.x_name;
    }
    
    static function x_getter(entities : [x_entity]) : [srt1] {
      return [x_entity.x_getter(en) | en : x_entity in entities where x_entity.x_getter(en) != null];
    }
	]|
		where
			is-attributename
		where
			attributename-is-normal
		with
      x_entity           := <attributename-get-entityname>x_name;
      x_getter           := $[get_[x_name]];
      srt1               := <_get-type;type-to-webdsl(err)>x_name

rules // attributes: default

  to-webdsl-eager(err): x_name -> webdsl |[
    x_name    : srt1 (default=null)
    x_default : srt1 (default=x_calc())
    
    function x_calc() : srt1{
      return e1;
    }
    
    static function x_getter(en : x_entity) : srt1 {
      return if(en == null) null as srt1 else if(en.x_name == null) en.x_default else en.x_name;
    }
    
    static function x_getter(entities : [x_entity]) : [srt1] {
      return [x_entity.x_getter(en) | en : x_entity in entities where x_entity.x_getter(en) != null];
    }
    
    function x_update() {
      x_default := x_calc();
    }
    
    static function x_updateAll () {
      var entities := x_entity.x_getAndEmptyDirty();
      if(entities.length != 0){
        log("Updating " + e2 + ": " + entities.length);
      }
      for(en in entities){
        en.x_update();
      }
    }
    
    static function x_getAndEmptyDirty () : Set<x_entity> {
      var values := x_dirtyCollection;
      x_dirtyCollection := Set<x_entity>();
      return values;
    }
    
    static function x_hasDirty () : Bool {
      return x_dirtyCollection.length!=0;
    }
    
    static function x_flagDirty(en : x_entity) {
      x_entity.x_flagDirty([en]);
    }
    
    static function x_flagDirty(entities : [x_entity]) {
      x_dirtyCollection.addAll(entities);
    }
    
  ]|
    where
      is-attributename
    where
      attributename-is-default
    with
      x_entity           := <attributename-get-entityname>x_name;
      x_getter           := $[get_[x_name]];
      x_calc             := $[calculate_[x_name]];
      x_update           := $[update_[x_name]];
      x_getAndEmptyDirty := $[get_and_empty_[x_name]_dirty];
      x_updateAll        := $[[x_name]_update_all];
      x_hasDirty         := $[[x_name]_has_dirty];
      x_flagDirty        := $[[x_name]_flag_dirty];
      x_default          := $[[x_name]_Default];
      x_dirtyCollection  := $[[x_entity]_[x_name]_dirty];
      srt1               := <_get-type;type-to-webdsl(err)>x_name;
      e1                 := <attributename-get-expr;to-webdsl(err)>x_name;
      e2                 := String($[[x_entity].[x_name]])

rules // attributes: derivation

  to-webdsl-eager(err): x_name -> webdsl |[
    x_name : srt1 (default=x_calc())
    
    function x_calc() : srt1{
      return e1;
    }
    
    static function x_getter(en : x_entity) : srt1 {
      return if(en == null) null as srt1 else en.x_name;
    }
    
    static function x_getter(entities : [x_entity]) : [srt1] {
      return [x_entity.x_getter(en) | en : x_entity in entities where x_entity.x_getter(en) != null];
    }
    
    function x_update() {
      x_name := x_calc();
    }
    
    static function x_updateAll () {
      var entities := x_entity.x_getAndEmptyDirty();
      if(entities.length != 0){
        log("Updating " + e2 + ": " + entities.length);
      }
      for(en in entities){
        en.x_update();
      }
    }
    
    static function x_getAndEmptyDirty () : Set<x_entity> {
      var values := x_dirtyCollection;
      x_dirtyCollection := Set<x_entity>();
      return values;
    }
    
    static function x_hasDirty () : Bool {
      return x_dirtyCollection.length!=0;
    }
    
    static function x_flagDirty(en : x_entity) {
      x_entity.x_flagDirty([en]);
    }
    
    static function x_flagDirty(entities : [x_entity]) {
      x_dirtyCollection.addAll(entities);
    }
  ]|
    where
      is-attributename
    where
      attributename-is-derivation
    with
      x_entity           := <attributename-get-entityname>x_name;
      x_getter           := $[get_[x_name]];
      x_calc             := $[calculate_[x_name]];
      x_update           := $[update_[x_name]];
      x_getAndEmptyDirty := $[get_and_empty_[x_name]_dirty];
      x_updateAll        := $[[x_name]_update_all];
      x_hasDirty         := $[[x_name]_has_dirty];
      x_flagDirty        := $[[x_name]_flag_dirty];
      x_dirtyCollection  := $[[x_entity]_[x_name]_dirty];
      srt1               := <_get-type;type-to-webdsl(err)>x_name;
      e1                 := <attributename-get-expr;to-webdsl(err)>x_name;
      e2                 := String($[[x_entity].[x_name]])

rules // attributes - trigger dirty
			
	to-webdsl-eager-trigger-dirty(err): x_name -> [webdsl |[
    extend function x_set(newValue:srt1){
    	if(x_name != newValue){
    		stat1*
    	}
    }
	]|]
		where
			is-attributename
    where
      attributename-is-normal <+ attributename-is-derivation
		where
			flowsToPaths := <name-get-flowsto-paths;list-not-empty>x_name
		with
			srt1   := <_get-type;type-to-webdsl(err)>x_name;
			x_set  := $[set[<ucfirst>x_name]];
			stat1* := <map(ttuple(path-get-last, path-remove-end;path-to-expr);flagdirty-webdslstat(err))>flowsToPaths

  to-webdsl-eager-trigger-dirty(err): x_name -> webdsl |[
    extend function x_set(newValue:srt1){ // if the custom value is changed
      if(x_name != newValue){
        stat1*
      }
    }
    extend function x_setDef(newValue:srt1){ // if the default value changes and there is no custom value
      if(x_name == null && x_default != newValue){
        stat1*
      }
    }
  ]|
    where
      is-attributename
    where
      attributename-is-default
    where
      flowsToPaths := <name-get-flowsto-paths;list-not-empty>x_name
    with
      srt1      := <_get-type;type-to-webdsl(err)>x_name;
      x_default := $[[x_name]_Default];
      x_set     := $[set[<ucfirst>x_name]];
      x_setDef  := $[set[<ucfirst>x_default]];
      stat1*    := <map(ttuple(path-get-last, path-remove-end;path-to-expr);flagdirty-webdslstat(err))>flowsToPaths

rules // roles - trigger dirty

	to-webdsl-eager-trigger-dirty(err): x_name -> webdsl |[
    extend function x_set(newValue:srt1){
    	if(x_name != newValue){
	    	stat1*
	    	stat2*
	    	stat3*
    	}
    }
	]|
		where
			is-rolename
		where
			flowsToPaths := <name-get-flowsto-paths;list-not-empty>x_name
		with
			newValueExpr := Ref("newValue"){(NablProp_multiplicity(), <get-multiplicity>x_name), (Type(), <_get-type>x_name)};
			srt1   := <_get-type;type-to-webdsl(err)>x_name;
			x_set  := $[set[<ucfirst>x_name]];
			stat1* := <filter(path-origin-is-inverse);map(                   ttuple(path-get-last, path-remove-end;path-to-expr               );flagdirty-webdslstat(err))>flowsToPaths;
			stat2* := <filter(path-origin-is-role)   ;map(path-prependorigin;ttuple(path-get-last, path-remove-end;path-to-expr               );flagdirty-webdslstat(err))>flowsToPaths;
			stat3* := <filter(path-origin-is-role)   ;map(                   ttuple(path-get-last, path-remove-end;path-to-expr(|newValueExpr));flagdirty-webdslstat(err))>flowsToPaths

rules // helper
	
	flagdirty-webdslstat(err): (attrName, expr) -> webdsl |[
		if(e1 != null){
			// log("Attribute " + e2 + " is dirty of " + e1);
			x_entity.x_flagDirty(e1);
		}
	]|
		with
			e1          := <to-webdsl(err)>expr;
			e2          := String(attrName);
      x_entity    := <attributename-get-entityname>attrName;
      x_flagDirty := $[[attrName]_flag_dirty]
