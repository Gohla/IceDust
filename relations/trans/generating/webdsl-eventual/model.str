module trans/generating/webdsl-eventual/model

imports // constructors

	trans/api/_runtime-constructors
	trans/api/constructors
	lib/webdsl/WebDSL
	src-gen/signatures/Expressions-sig
	src-gen/signatures/Model-sig
	src-gen/signatures/Modules-sig
	trans/desugaring/constructors

imports // functions

	trans/analysis2/path
	trans/api/_runtime
	trans/api/model-api
	trans/api/model-names-api
	trans/lib/search
	trans/lib/string
	trans/lib/lists-tuples
	trans/naming/names
	trans/naming/_notNaBL
	trans/generating/webdsl/expressions
	trans/generating/webdsl/expressions-references
	trans/generating/webdsl/model
	trans/generating/webdsl/types

rules // entities
	
  to-webdsl-eventual(err): x_name -> 
		webdsl |[
			entity x_name {
				ebd1*
				ebd2*
				ebd3*
				ebd4*
				ebd5*
			}
		]|
	where
		is-entityname
	with
		ebd1* := <entityname-get-attributenames;map(to-webdsl-eventual(err))>x_name;
		ebd2* := <entityname-get-rolenames;     map(to-webdsl(err))>x_name;
		ebd3* := <entityname-get-inversenames;  map(to-webdsl(err))>x_name;
		ebd4* := <entityname-get-attributenames;filter(to-webdsl-eventual-trigger-dirty(err));flatten-list>x_name;
		ebd5* := <entityname-get-rolenames;     filter(to-webdsl-eventual-trigger-dirty(err))>x_name

rules // attributes: normal

	to-webdsl-eventual(err): x_name -> webdsl |[
		x_name : srt1 (default=null)
    
    static function x_getter(en: x_entity) : srt1 {
      return if(en == null) null as srt1 else en.x_name;
    }
    
    static function x_getter(entities : [x_entity]) : [srt1] {
      return [x_entity.x_getter(en) | en : x_entity in entities where x_entity.x_getter(en) != null];
    }
	]|
		where
			is-attributename
		where
			attributename-is-normal
		with
      x_entity           := <attributename-get-entityname>x_name;
      x_getter           := $[get_[x_name]];
      srt1               := <_get-type;type-to-webdsl(err)>x_name

rules // attributes: default

	to-webdsl-eventual(err): x_name -> webdsl |[
		x_name    : srt1 (default=null) //no default, because the default instantiates in WebDSL and then is not updated anymore
		x_default : srt1 (default=x_calc())
    
    function x_calc() : srt1{
      return e1;
    }
    
    static function x_getter(en : x_entity) : srt1 {
      return if(en == null) null as srt1 else if(en.x_name == null) en.x_default else en.x_name;
    }
    
    static function x_getter(entities : [x_entity]) : [srt1] {
      return [x_entity.x_getter(en) | en : x_entity in entities where x_entity.x_getter(en) != null];
    }
    
    function x_update() {
    	x_default := x_calc();
    }
    
    static function x_updateAll () {
      var entities := x_entity.x_getAndEmptyDirty();
      if(entities.length != 0){
        log("Updating " + e2 + ": " + entities.length);
      }
      for(en in entities){
        en.x_update();
      }
    }
    
    static function x_getAndEmptyDirty ( ) : Set<x_entity>
    {
    	var queue := DirtyCollections.x_queue();
    	var values : Set<x_entity>;
    	while(!queue.isEmpty()){
	  		var v : x_entity := loadEntity(e3, UUIDFromString(queue.poll() as String)) as x_entity;
	  		if(v != null){
	  			values.add(v);
	  		}
	  	}
      return values;
    }
    
    static function x_hasDirty () : Bool {
    	return !DirtyCollections.x_queue().isEmpty();
    }
	]|
		where
			is-attributename
		where
			attributename-is-default
		with
      x_entity           := <attributename-get-entityname>x_name;
      x_getter           := $[get_[x_name]];
      x_calc             := $[calculate_[x_name]];
      x_update           := $[update_[x_name]];
      x_getAndEmptyDirty := $[get_and_empty_[x_name]_dirty];
      x_updateAll        := $[[x_name]_update_all];
      x_hasDirty         := $[[x_name]_has_dirty];
      x_default          := $[[x_name]_Default];
      x_queue            := $[get_[x_entity]_[x_name]_queue];
      srt1               := <_get-type;type-to-webdsl(err)>x_name;
      e1                 := <attributename-get-expr;to-webdsl(err)>x_name;
      e2                 := String($[[x_entity].[x_name]]);
      e3                 := String(x_entity)

rules // attributes: derivation

	to-webdsl-eventual(err): x_name -> webdsl |[
		x_name : srt1 (default=x_calc()) //add a default, so that WebDSL instantiates the derived value (note this value may be wrong if other values are not up to date yet, but then it will be dirty flagged again)
    
    function x_calc() : srt1{
      return e1;
    }
    
    static function x_getter(en : x_entity) : srt1 {
      return if(en == null) null as srt1 else en.x_name;
    }
    
    static function x_getter(entities : [x_entity]) : [srt1] {
      return [x_entity.x_getter(en) | en : x_entity in entities where x_entity.x_getter(en) != null];
    }
    
    function x_update() {
    	x_name := x_calc();
    }
    
    static function x_updateAll () {
      var entities := x_entity.x_getAndEmptyDirty();
      if(entities.length != 0){
        log("Updating " + e2 + ": " + entities.length);
      }
      for(en in entities){
        en.x_update();
      }
    }
    
    static function x_getAndEmptyDirty ( ) : Set<x_entity>
    {
    	var queue := DirtyCollections.x_queue();
    	var values : Set<x_entity>;
    	while(!queue.isEmpty()){
	  		var v : x_entity := loadEntity(e3, UUIDFromString(queue.poll() as String)) as x_entity;
	  		if(v != null){
	  			values.add(v);
	  		}
	  	}
      return values;
    }
    
    static function x_hasDirty () : Bool {
    	return !DirtyCollections.x_queue().isEmpty();
    }
	]|
		where
			is-attributename
		where
			attributename-is-derivation
		with
      x_entity           := <attributename-get-entityname>x_name;
      x_getter           := $[get_[x_name]];
      x_calc             := $[calculate_[x_name]];
      x_update           := $[update_[x_name]];
      x_getAndEmptyDirty := $[get_and_empty_[x_name]_dirty];
      x_updateAll        := $[[x_name]_update_all];
      x_hasDirty         := $[[x_name]_has_dirty];
      x_queue            := $[get_[x_entity]_[x_name]_queue];
      srt1               := <_get-type;type-to-webdsl(err)>x_name;
      e1                 := <attributename-get-expr;to-webdsl(err)>x_name;
      e2                 := String($[[x_entity].[x_name]]);
      e3                 := String(x_entity)

rules // attributes - trigger dirty
			
	to-webdsl-eventual-trigger-dirty(err): x_name -> [webdsl |[
    extend function x_set(newValue:srt1){
    	if(x_name != newValue){
    		stat1*
    	}
    }
	]|]
		where
			is-attributename
		where
			attributename-is-normal <+ attributename-is-derivation
		where
			flowsToPaths := <name-get-flowsto-paths;list-not-empty>x_name
		with
			srt1   := <_get-type;type-to-webdsl(err)>x_name;
			x_set  := $[set[<ucfirst>x_name]];
			stat1* := <map(ttuple(path-get-last, path-remove-end;path-to-expr);flagdirty-webdslstat-eventual(err))>flowsToPaths		
				
	to-webdsl-eventual-trigger-dirty(err): x_name -> webdsl |[
    extend function x_set(newValue:srt1){ // if the custom value is changed
    	if(x_name != newValue){
    		stat1*
    	}
    }
    extend function x_setDef(newValue:srt1){ // if the default value changes and there is no custom value
    	if(x_name == null && x_default != newValue){
    		stat1*
    	}
    }
	]|
		where
			is-attributename
		where
			attributename-is-default
		where
			flowsToPaths := <name-get-flowsto-paths;list-not-empty>x_name
		with
			srt1      := <_get-type;type-to-webdsl(err)>x_name;
			x_default := $[[x_name]_Default];
			x_set     := $[set[<ucfirst>x_name]];
			x_setDef  := $[set[<ucfirst>x_default]];
			stat1*    := <map(ttuple(path-get-last, path-remove-end;path-to-expr);flagdirty-webdslstat-eventual(err))>flowsToPaths

rules // roles - trigger dirty

	to-webdsl-eventual-trigger-dirty(err): x_name -> webdsl |[
    extend function x_set(newValue:srt1){
    	if(x_name != newValue){
	    	stat1*
	    	stat2*
	    	stat3*
    	}
    }
	]|
		where
			is-rolename
		where
			flowsToPaths := <name-get-flowsto-paths;list-not-empty>x_name
		with
			newValueExpr := Ref("newValue"){(NablProp_multiplicity(), <get-multiplicity>x_name), (Type(), <_get-type>x_name)};
			srt1   := <_get-type;type-to-webdsl(err)>x_name;
			x_set  := $[set[<ucfirst>x_name]];
			stat1* := <filter(path-origin-is-inverse);map(                   ttuple(path-get-last, path-remove-end;path-to-expr               );flagdirty-webdslstat-eventual(err))>flowsToPaths;
			stat2* := <filter(path-origin-is-role)   ;map(path-prependorigin;ttuple(path-get-last, path-remove-end;path-to-expr               );flagdirty-webdslstat-eventual(err))>flowsToPaths;
			stat3* := <filter(path-origin-is-role)   ;map(                   ttuple(path-get-last, path-remove-end;path-to-expr(|newValueExpr));flagdirty-webdslstat-eventual(err))>flowsToPaths

rules // helper
	
	flagdirty-webdslstat-eventual(err): (attrName, expr) -> webdsl |[
		if(e1 != null){
			// log("Attribute " + e2 + " is dirty of " + e1);
			// x_dirty.add(e1);
			DirtyCollections.x_queue().offer(e1.id.toString());
		}
	]|
		where
			<get-multiplicity;upper-one>expr
		with
			e1      := <to-webdsl(err)>expr;
			e2      := String(attrName);
			// x_dirty := $[[<attributename-get-entityname>attrName]_[attrName]_dirty];
			x_queue := $[get_[<attributename-get-entityname>attrName]_[attrName]_queue]
	
	flagdirty-webdslstat-eventual(err): (attrName, expr) -> webdsl |[
		// log("Attribute " + e2 + " is dirty of " + e1);
		// x_dirty.addAll(e1);
		DirtyCollections.x_queue().addAll([v.id.toString()|v : x_entity in e1]);
	]|
		where
			<get-multiplicity;upper-many>expr
		with
			e1      := <to-webdsl(err)>expr;
			e2      := String(attrName);
			x_entity:= <attributename-get-entityname>attrName;
			// x_dirty := $[[x_entity]_[attrName]_dirty];
			x_queue := $[get_[x_entity]_[attrName]_queue]
