module generating/webdsl-eventual/module

imports // constructors

	webdsl/constructors
	webdsl/WebDSL
	desugaring/constructors

imports // functions
	
	generating/webdsl-eventual/model
	generating/webdsl/data
	api/module-api
	api/module-names-api
	api/model-names-api
	lib/debug
	lib/lists-tuples
	lib/string

rules // module

	to-webdsl-eventual(err) = module-get-modulename;to-webdsl-eventual(err)

	to-webdsl-eventual(err): x_name -> 
			webdsl |[
				application x_name
				
				imports relations/crud-ui
				imports relations/Expressions
        imports relations/eventually-consistent
			
				section model
				
					def1*
				
				section derivations
				
          def3*
          
          init{
            initDirtyCollections();
          }
          
          function initDirtyCollections(){

          }
				
					native class derivations.x_dirty as DirtyCollections {
						native1*
					}

          function flagAllDirty(){
            stat5*
          }

          function flagDirty(entity:String, attribute:String){
            stat6*
          }
          
          function flagDirtyAsync() {
            //propagate changes to worker thread: flagDirtyAsync
          }
				
					function updateDerivations(){
						if(!getUpdatesEnabled()){
				  		return;
				  	}
				  	flagDirtyAsync();
						var notEmpty : Bool;
						stat4*
					}
					
  				invoke updateDerivations() every 3 seconds
				
				section data
					
					init{
						stat1*
						stat2*
						stat3*
					}
				
				section ui
					
					define applicationmenu() {
						elem1*
					}
					
					def2*
				
			]|
		where
			is-modulename
		with
			def1*  := <modulename-get-entitynames;map(to-webdsl-eventual(err))>x_name;
			def2*  := <modulename-get-entitynames;map(webdsl-crud-eventual)>x_name;
			elem1* := <modulename-get-entitynames;map(webdsl-crud-nav)>x_name;
			stat1* := <modulename-get-entityinstancenames;map(to-webdsl-1(err))>x_name;
			stat2* := <modulename-get-entityinstancenames;map(to-webdsl-2(err))>x_name;
			stat3* := <modulename-get-entityinstancenames;map(to-webdsl-3(err))>x_name;
			def3*  := <modulename-get-entitynames;map(entityname-get-attributenames);flatten-list;filter(where(not(attributename-is-normal)));map(attribute-dirty-collection-eventual)>x_name;
			stat4* := <modulename-get-attributenames-topo;webdsl-toposort-eventual>x_name;
			x_dirty:= $[[x_name]_Dirty];
			native1*:= <modulename-get-entitynames;map(entityname-get-attributenames);flatten-list;filter(where(not(attributename-is-normal)));map(attribute-dirty-queue)>x_name;
      stat5*  := <modulename-get-attributenames-topo;flatten-list;filter(where(not(attributename-is-normal)));map(attribute-flagalldirty)>x_name;
      stat6*  := <modulename-get-attributenames;                  filter(where(not(attributename-is-normal)));map(attribute-flagdirty)>x_name
			

rules //crud
	
	webdsl-crud-eventual: x_name -> webdsl* |[
		define page x_create(){
      //derive createPage from temp
      main()
      define body() {
        var temp := x_name{}
        header{"Create " output(temp.name) } 
        form { 
          <fieldset>
            <legend>
              output("Details")
            </legend>
            <table>
            	elem1
              // derive editRows from temp
            </table>
          </fieldset>      
          action("Save", save())
        }
        action save() { 
          temp.save();
          // updateDerivations();
          return x_manage();
        }
      }
    }
    define page x_view(arg : x_name){
      derive viewPage from arg
    }
		define page x_edit(arg : x_name){
		  //derive editPage from arg
		  main()
		  define body() {
		    header{"Edit " output(arg.name) } 
		    form { 
		      <fieldset>
		        <legend>
		          output("Details")
		        </legend>
		        <table>
		        	elem2
		          // derive editRows from arg
		        </table>
		      </fieldset>  
		      action("Save", save())
		    }
		    action save() { 
		      arg.save();
		      // updateDerivations();
		      return x_manage();
		    }
		  }
		}
		define page x_manage(){
		  main()
		  define body(){
		    navigate(x_create()){ "create" }
		    <list>
		      for(elem : x_name){
		        <li> 
		          output(elem)
		          " "
		          navigate(x_edit(elem)){ "edit" }
		          " "
		          form{action("remove",remove(elem))}
		        </li>
		      }
		    </list>
		    action remove(arg : x_name){
		      arg.delete();
		    }
		  }
		}
	]|
		with
			x_manage := $[manage[x_name]];
			x_create := $[create[x_name]];
			x_edit   := $[edit[x_name]];
			x_view   := <lcfirst>x_name;
			form-fields := <concat(
				                entityname-get-attributenames;filter(where(not(attributename-is-derivation))),
				                entityname-get-rolenames,
				                entityname-get-inversenames
			                );map(webdsl-crud-attr)>x_name;
			elem1    := Derive("editRows", Var("temp"), form-fields);
			elem2    := Derive("editRows", Var("arg"),  form-fields)
	
	webdsl-crud-attr: x_name -> DeriveDefault(x_name)
	
	webdsl-crud-nav: x_name -> webdsl |[navbaritem{navigate x_manageName(){$text}}]|
		with
			x_manageName := $[manage[x_name]];
			$text := Text(x_name)
	
rules // derivations
	
	attribute-dirty-collection-eventual: x_name -> def* |[
		request var x_dirty := Set<x_entity>()
		
	  extend function initDirtyCollections() {
	  	x_dirty := Set<x_entity>();
	  }
	  
	  extend function flagDirtyAsync() {
	    x_entity.x_flagDirtyAsync();
	  }
	]|
		with
			x_entity         := <attributename-get-entityname>x_name;
			x_dirty          := $[[x_entity]_[x_name]_dirty];
      x_flagDirtyAsync := $[[x_name]_flag_dirty_async]

	attribute-dirty-queue: x_name -> |[static x_get() : Queue]|
		where
			<is-attributename>x_name
		with
			x_entity := <attributename-get-entityname>x_name;
			x_get    := $[get_[x_entity]_[x_name]_queue]

rules // List(List(String)) -> Webdsl-stat*

	webdsl-toposort-eventual : namess -> result
		with
			namess' := <map(filter(where(is-attributename;not(attributename-is-normal))));filter(list-not-empty)>namess;
			result  := <map(webdsl-update-group-eventual)>namess'
	
	webdsl-update-group-eventual : names -> webdsl |[
		notEmpty := true;
		while(notEmpty){
			stat1*
			flagDirtyAsync();
			notEmpty := false;
			stat2*
		}
	]|
		with
			stat1* := <map(webdsl-update-dirty-eventual)>names;
			stat2* := <map(webdsl-has-dirty-eventual)>names
	
	webdsl-update-dirty-eventual : x_name -> |[x_entity.x_updateAllAsync();]|
		with
			x_entity := <attributename-get-entityname>x_name;
      x_updateAllAsync   := $[[x_name]_update_all_async]
			
	webdsl-has-dirty-eventual : x_name -> |[notEmpty := notEmpty || x_entity.x_hasDirtyAsync();]|
		with
			x_entity := <attributename-get-entityname>x_name;
      x_hasDirtyAsync    := $[[x_name]_has_dirty_async]

rules //flag dirty manually
  
  attribute-flagalldirty: x_name -> |[
    DirtyCollections.x_queue().addAll([a.id.toString() | a:x_entity in (from x_entity)]);
  ]|
    with
      x_entity := <attributename-get-entityname>x_name;
      x_queue  := $[get_[x_entity]_[x_name]_queue]
        
  attribute-flagdirty: x_name -> |[
    if(entity==e1 && attribute==e2){
      DirtyCollections.x_queue().addAll([a.id.toString() | a:x_entity in (from x_entity)]);
    }
  ]|
    with
      x_entity := <attributename-get-entityname>x_name;
      x_queue  := $[get_[x_entity]_[x_name]_queue];
      e1       := String(x_entity);
      e2       := String(x_name)

