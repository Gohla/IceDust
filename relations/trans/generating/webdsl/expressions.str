module trans/generating/webdsl/expressions

imports // constructors

  lib/webdsl/constructors
  lib/webdsl/WebDSL
  src-gen/signatures/Data-sig
  src-gen/signatures/Expressions-sig  
  trans/desugaring/constructors

imports // functions

  trans/api/_runtime  
  trans/api/module-names-api
  trans/generating/java/expressions
  trans/generating/java/types
  trans/generating/webdsl/model
  trans/generating/webdsl/data
  trans/generating/webdsl/types
  trans/naming/names

rules // WebDSL specific: no generics, explicit casts
  
  webdsl-lib-call-cast = ?TernaryConditional(_,_,_)

  webdsl-lib-call-cast = ?Merge(_, _)
  webdsl-lib-call-cast = ?ChoiceLeft(_, _)

rules // lib expression calls
  
  to-webdsl(err): e -> |[ Expressions.x_method (e1) ]|
    where
      x_method := <lib-call>e;
      [ex1] := <get-arguments>e
    with
      e1 := <to-webdsl(err)>ex1
  
  to-webdsl(err): e -> |[ Expressions.x_methodpostfix (e1) ]|
    where
      x_method := <lib-call-postfix-type>e;
      [ex1] := <get-arguments>e
    with
      e1 := <to-webdsl(err)>ex1;
      x_methodpostfix := $[[x_method]_[<_get-type;java-id>e]]

  to-webdsl(err): e -> |[ Expressions.x_method (e1, e2) ]|
    where
      x_method := <lib-call>e;
      [ex1, ex2] := <get-arguments>e
    with
      e1 := <to-webdsl(err)>ex1;
      e2 := <to-webdsl(err)>ex2

  to-webdsl(err): e -> |[ Expressions.x_methodpostfix (e1, e2) ]|
    where
      x_method := <lib-call-postfix-type>e;
      [ex1, ex2] := <get-arguments>e
    with
      e1 := <to-webdsl(err)>ex1;
      e2 := <to-webdsl(err)>ex2;
      if <not(eq)>(<_get-type>e1, NoValue()) then
        x_methodpostfix := $[[x_method]_[<_get-type;java-id>ex1]]
      else
        x_methodpostfix := $[[x_method]_[<_get-type;java-id>ex2]]
      end

  to-webdsl(err): e -> |[ Expressions.x_methodpostfix (e1, e2) ]|
    where
      x_method := <lib-call-postfix-mults>e;
      [ex1, ex2] := <get-arguments>e;
      <not(webdsl-lib-call-cast)>e
    with
      e1 := <to-webdsl(err)>ex1;
      e2 := <to-webdsl(err)>ex2;
      x_methodpostfix := $[[x_method]_[<get-multiplicity;java-id>ex1]_[<get-multiplicity;java-id>ex2]]

  to-webdsl(err): e -> |[ Expressions.x_methodpostfix(e1, e2) as srt1 ]|    
    where
      x_method := <lib-call-postfix-mults>e;
      [ex1, ex2] := <get-arguments>e;
      <webdsl-lib-call-cast>e
    with
      e1 := <to-webdsl(err)>ex1;
      e2 := <to-webdsl(err)>ex2;
      x_methodpostfix := $[[x_method]_[<get-multiplicity;java-id>ex1]_[<get-multiplicity;java-id>ex2]];
      srt1 := <webdsl-type(err)>e
      
  to-webdsl(err): e -> |[ Expressions.x_methodpostfix(e1, e2, e3) as srt1 ]|
    where
      x_method := <lib-call-postfix-mults>e;
      [ex1, ex2, ex3] := <get-arguments>e;
      <webdsl-lib-call-cast>e
    with
      e1 := <to-webdsl(err)>ex1;
      e2 := <to-webdsl(err)>ex2;
      e3 := <to-webdsl(err)>ex3;
      x_methodpostfix := $[[x_method]_[<get-multiplicity;java-id>ex1]_[<get-multiplicity;java-id>ex2]_[<get-multiplicity;java-id>ex3]];
      srt1 := <webdsl-type(err)>e

rules // literals
  
  to-webdsl(err): String(str1)                    -> String(str1)
  to-webdsl(err): Int(i_1)                        -> webdsl:e |[ i_1 ]|
  to-webdsl(err): Float(f_1)                      -> Float(f_1)//webdsl:e |[ f_1 ]|
  to-webdsl(err): True()                          -> webdsl:e |[ true ]|
  to-webdsl(err): False()                         -> webdsl:e |[ false ]|
  to-webdsl(err): Datetime(str1)                  -> webdsl:e |[Expressions.parseDatetime(e1)]| with e1 := String(str1)
  to-webdsl(err): NoValue()                       -> webdsl:e |[ null ]|

rules // casts
  
  to-webdsl(err): Cast(NoValue() , ex1-ty) -> |[ null as x ]| where x := <type-as-string>ex1-ty
  
  to-webdsl(err): Cast(ex1, ex1-ty) -> |[ Expressions.x_method(e1) ]|
    with
      e1 := <to-webdsl(err)>ex1;
      x_method := $[as[<java-id>ex1-ty]]

rules
  