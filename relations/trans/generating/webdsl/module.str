module generating/webdsl/module

imports // constructors

	webdsl/constructors
	webdsl/WebDSL
	desugaring/constructors

imports // functions
  
  generating/_ir/model 
  generating/webdsl/model
	generating/webdsl/data
  api/model-names-api
	api/module-api
  api/module-names-api
  lib/lists-tuples
  lib/string

rules // module

	modulename-to-webdsl-application(err): x_moduleName -> result
		where
			is-modulename
		with
			def1*          := <modulename-get-entitynames;map(model-entityname-to-webdsl-def(err))>x_moduleName;
			def2*          := <modulename-get-entitynames;map(entityname-to-webdsl-defs);flatten-list>x_moduleName;
			elem_menu*     := <modulename-get-entitynames;map(entityname-to-webdsl-elem)>x_moduleName;
			stat_initdata* := <data-modulename-to-webdsl-stms(err)>x_moduleName
		with
		  if (modulename-is-calconwrite<+modulename-is-eventuallyconsistent) then
		    def3*            := <modulename-get-attributenames;filter(where(not(attributename-is-normal)));map(attributename-to-webdsl-defs);flatten-list>x_moduleName;
		    stat_cach*       := <cache-modulename-to-webdsl-stms>x_moduleName;
		    stat_initdcoll*  := stat* |[initDirtyCollections();]|
		  else
        stat_initdcoll*  := []
		  end
		with
		  if modulename-is-calconwrite then
		    stat_initupdate* := stat* |[updateDerivations();]|
		  else if modulename-is-eventuallyconsistent then
		    stat_initupdate* := stat* |[flagDirtyAsync();]|
		  else
        stat_initupdate* := []
		  end end
    with
      if modulename-is-eventuallyconsistent then
        stat_flagasync*    := <modulename-get-attributenames;filter(where(not(attributename-is-normal)));map(attributename-to-webdsl-stat)>x_moduleName;
        stat_receiveasync* := <modulename-get-attributenames;filter(where(not(attributename-is-normal)));map(attributename-to-webdsl-stat2)>x_moduleName;
        native1*           := <modulename-get-attributenames;filter(where(not(attributename-is-normal)));map(attributename-to-webdsl-native)>x_moduleName
      end
    with
      sec0* := webdsl |[ // webdsl Section
        section model
        
          def1*
        
        section data
          
          init{
            stat_initdcoll*
            stat_initdata*
            stat_initupdate*
          }
        
        section ui
        
          define applicationmenu() {
            elem_menu*
          }
          
          def2*
        
        section hibernate hooks
        
          function beforeTransactionCompletion(){
          
          }
          
          function afterTransactionCompletion(){
          
          }
      ]|
    with
      if (modulename-is-calconwrite<+modulename-is-eventuallyconsistent) then  
        sec1* := [webdsl |[ // webdsl Section
          section caches and dirty flags
          
            def3*
            
            function initDirtyCollections(){
  
            }
            
            // calconwrite: call before flush to db
            function updateDerivations(){
              stat_cach*
            }
        ]|]
      else
        sec1* := []
      end
    with
      if modulename-is-eventuallyconsistent then
        sec2* := [webdsl |[ // webdsl Section
          section async dirty flags
            
            extend function afterTransactionCompletion(){
              flagDirtyAsync();
            }
            
            function flagDirtyAsync(){
              stat_flagasync*
            }
            
            function updateDerivationsAsync(){
              initDirtyCollections();
              stat_receiveasync*
              updateDerivations();
            }
            
            invoke updateDerivationsAsync() every 3 seconds
            
            native class derivations.DirtyCollections as DirtyCollections {
              native1*
            }
            
            native class java.util.Queue as Queue{
              offer(String) : Bool
              add(String) : Bool
              addAll(List<String>) : Bool
              poll() : String
              contains(String) : Bool
              isEmpty() : Bool
            }
        ]|]
      else
        sec2* := []
      end
	  with
	    if modulename-is-noui then
      result := application |[
        application x_moduleName
        
        imports lib/relations/crud-ui
        imports lib/relations/Expressions
      
        sec0* // model, data, ui and hibernate hooks
        
        sec1* // caches and dirty flags
        
        sec2* // async dirty flags
      ]|
    else
      result := module |[
        module x_moduleName
        
        imports lib/relations/crud-ui
        imports lib/relations/Expressions
      
        sec0* // model, data, ui and hibernate hooks
        
        sec1* // caches and dirty flags
        
        sec2* // async dirty flags
      ]|
    end

rules //crud
	
  entityname-to-webdsl-defs: x_entityName -> result
    with
      x_manageEntity := <name-manage>x_entityName;
      x_createEntity := <name-create>x_entityName;
      x_editEntity   := <name-edit>x_entityName;
      x_viewEntity   := <lcfirst>x_entityName;
      form-fields :=
        <concat(
          entityname-get-attributenames;filter(where(not(attributename-is-derivation))),
          entityname-get-rolenames,
          entityname-get-inversenames
        );map(attributename-to-webdsl)>x_entityName;
      elem_deriveEditRowsTemp := Derive("editRows", Var("temp"), form-fields);
      elem_deriveEditRowsArg  := Derive("editRows", Var("arg"),  form-fields)
    with
      if entityname-is-calconwrite then
        stat_updateDerivations* := stat* |[
          updateDerivations();
        ]|
      else
        stat_updateDerivations* := []
      end
    with
      if entityname-is-calconread then
        result := [DeriveCrud(x_entityName)]
      else
        result := def* |[
          define page x_createEntity(){
            //derive createPage from temp
            main()
            define body() {
              var temp := x_entityName{}
              header{"Create " output(temp.name) } 
              form { 
                <fieldset>
                  <legend>
                    output("Details")
                  </legend>
                  <table>
                    elem_deriveEditRowsTemp
                    // derive editRows from temp
                  </table>
                </fieldset>      
                action("Save", save())
              }
              action save() { 
                temp.save();
                stat_updateDerivations*
                return x_manageEntity();
              }
            }
          }
          define page x_viewEntity(arg : x_entityName){
            derive viewPage from arg
          }
          define page x_editEntity(arg : x_entityName){
            //derive editPage from arg
            main()
            define body() {
              header{"Edit " output(arg.name) } 
              form { 
                <fieldset>
                  <legend>
                    output("Details")
                  </legend>
                  <table>
                    elem_deriveEditRowsArg
                    // derive editRows from arg
                  </table>
                </fieldset>  
                action("Save", save())
              }
              action save() { 
                arg.save();
                stat_updateDerivations*
                return x_manageEntity();
              }
            }
          }
          define page x_manageEntity(){
            main()
            define body(){
              navigate(x_createEntity()){ "create" }
              <list>
                for(elem : x_entityName){
                  <li> 
                    output(elem)
                    " "
                    navigate(x_editEntity(elem)){ "edit" }
                    " "
                    form{action("remove",remove(elem))}
                  </li>
                }
              </list>
              action remove(arg : x_entityName){
                arg.delete();
              }
            }
          }
        ]|
      end
	
  attributename-to-webdsl: x_name -> DeriveDefault(x_name)
	
	entityname-to-webdsl-elem: x_entityName -> result
		with
			x_manageName := $[manage[x_entityName]];
			$text := Text(x_entityName)
		with
		  result := elem |[
		    navbaritem{navigate x_manageName(){$text}}
		  ]|
	
rules // derivations
  
  attributename-to-webdsl-defs: x_attributeName -> result
    with
      x_entityName := <attributename-get-entityname>x_attributeName;
      x_dirty      := <attributename-entityname-dirty>x_attributeName
    with
      result := def* |[
        request var x_dirty := Set<x_entityName>()
        
        extend function initDirtyCollections(){
          x_dirty := Set<x_entityName>();
        }
      ]|
      
  attributename-to-webdsl-stat: x_attributeName -> result
    with
      x_entityName                := <attributename-get-entityname>x_attributeName;
      x_flagAttributeDirtyAsync   := <name-flagdirtyasync>x_attributeName
    with
      result := stat |[
        x_entityName.x_flagAttributeDirtyAsync();
      ]|
      
  attributename-to-webdsl-stat2: x_attributeName -> result
    with
      x_entityName                := <attributename-get-entityname>x_attributeName;
      x_receiveAttributeDirtyAsync:= <name-receivedirtyasync>x_attributeName
    with
      result := stat |[
        x_entityName.x_receiveAttributeDirtyAsync();
      ]|
      
  attributename-to-webdsl-native: x_attributeName -> result
    with
      x_attributeGetQueue := <attributename-entityname-getqueue>x_attributeName
    with
      result := native |[
        static x_attributeGetQueue() : Queue
      ]|

rules
  
  cache-modulename-to-webdsl-stms: x_moduleName -> result
    with
      namess := <modulename-get-attributenames-topo;map(filter(where(is-attributename;not(attributename-is-normal))));filter(list-not-empty)>x_moduleName;
      stat_updat* := <map(cache-attributenames-to-webdsl-stms);flatten-list>namess
    with
      if (modulename-is-calconwrite<+modulename-is-eventuallyconsistent) then
        result := stat* |[
          var notEmpty : Bool;
          stat_updat*
        ]|
      else
        result := []
      end
      
  cache-attributenames-to-webdsl-stms: attributeNames -> result
    with
      stat_updat* := <map(cache-attributename-to-webdsl-stm-update)>attributeNames;
      stat_empty* := <map(cache-attributename-to-webdsl-stm-empty)>attributeNames
    with
      result := stat* |[
        notEmpty := true;
        while(notEmpty){
          stat_updat*
          notEmpty := false;
          stat_empty*
        }
      ]|
      
  cache-attributename-to-webdsl-stm-update: x_attributeName -> result
    with
      x_entityName              := <attributename-get-entityname>x_attributeName;
      x_updateAllAttributeCache := <name-updateallcache>x_attributeName
    with
      result := stat |[
        x_entityName.x_updateAllAttributeCache();
      ]|
      
  cache-attributename-to-webdsl-stm-empty: x_attributeName -> result
    with
      x_entityName              := <attributename-get-entityname>x_attributeName;
      x_hasDirty                := <name-hasdirty>x_attributeName
    with
      result := stat |[
        notEmpty := notEmpty || x_entityName.x_hasDirty();
      ]|
