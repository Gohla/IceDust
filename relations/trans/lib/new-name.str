module trans/lib/new-name

imports

	lib/editor-common.generated

rules // alternative implementation of newname, passing the names and counters around
	
	new-name: (prefix, history) -> (name, history')
		with
			history' := <update-history>(prefix, history);
			name := $[[prefix][<in-history>(prefix, history')]]

	in-history : (prefix, history) -> count
		where
			[(_, count)] := <filter(in-history-prefix(|prefix))>history
			
	in-history-prefix(|prefix): (prefix2, count) -> <id>
		where
			<eq>(prefix, prefix2)
			
	update-history: (prefix, history) -> [(prefix,1)|history]
		where
			not(in-history)

	update-history: (prefix, history) -> <map(try(update-history-prefix(|prefix)))>history
		where
			in-history
	
	update-history-prefix(|prefix): (prefix2, count) -> (prefix2, <inc>count)
		where
			<eq>(prefix, prefix2)

rules
	
	new-name-map(map-strategy): input-list -> output-list
		with
			(output-list, _) := <map-fold(map-strategy)>(input-list, [])

rules

	map-fold(map-strategy): ([], fold-base-value) -> ([], fold-base-value)

	map-fold(map-strategy): ([input-head|input-rest], fold-value) -> ([input-head'|input-rest'], fold-value'')
		with
			(input-head', fold-value') := <map-strategy>(input-head, fold-value);
			(input-rest', fold-value'') := <map-fold(map-strategy)>(input-rest, fold-value')
			
rules
	
	test-new-name: a -> a
		with
			(name1, history1) := <new-name;debug>("a",[]);
			(name2, history2) := <new-name;debug>("a",history1);
			(name3, history3) := <new-name;debug>("b",history2);
			(name4, history4) := <new-name;debug>("a",history3)