module _notNaBL

imports // constructors

	include/Relations //TODO: remove
	src-gen/signatures/Rules-sig
	trans/api/_runtime-constructors
	trans/api/constructors
	trans/desugaring/constructors //TODO: remove
	trans/naming/names
	
imports // functions
	
	trans/api/_runtime
	
imports //TODO: move to API

	lib/editor-common.generated

signature constructors //TODO: move
	
	Normal: DerivationType

/**
 *	Note: all these rules should go into NaBL and TS (when NaBL and TS support these)
 */

rules // unresolved references manual messages

	nabl-check-disable-unresolved = id

	nabl-constraint(|ctx):
		Ref(e) -> <fail>
		where
		  <_has-annotation(?Use(task))> e
		; msg  := ["Unresolved reference: ", e, " cannot be resolved to an EntityInstance, Attribute, Role, Inverse or Shortcut"]
		; <_task-create-error-on-failure(|ctx, task, msg)> e

	nabl-constraint(|ctx):
		MemberAccess(_, e) -> <fail>
		where
		  <_has-annotation(?Use(task))> e
		; msg  := ["Unresolved reference: ", e, " cannot be resolved to an Attribute, Role, Inverse or Shortcut"]
		; <_task-create-error-on-failure(|ctx, task, msg)> e

	nabl-constraint(|ctx):
		AttributeRef(e) -> <fail>
		where
		  <_has-annotation(?Use(task))> e
		; msg  := ["Unresolved reference: ", e, " cannot be resolved to an Attribute"]
		; <_task-create-error-on-failure(|ctx, task, msg)> e

	nabl-constraint(|ctx):
		RoleRef(e) -> <fail>
		where
		  <_has-annotation(?Use(task))> e
		; msg  := ["Unresolved reference: ", e, " cannot be resolved to a Role"]
		; <_task-create-error-on-failure(|ctx, task, msg)> e

	nabl-constraint(|ctx):
		EntityRef(e) -> <fail>
		where
		  <_has-annotation(?Use(task))> e
		; msg  := ["Unresolved reference: ", e, " cannot be resolved to an Entity"]
		; <_task-create-error-on-failure(|ctx, task, msg)> e

	nabl-constraint(|ctx):
		EntityInstanceRef(e) -> <fail>
		where
		  <_has-annotation(?Use(task))> e
		; msg  := ["Unresolved reference: ", e, " cannot be resolved to an EntityInstance"]
		; <_task-create-error-on-failure(|ctx, task, msg)> e
		  
	nabl-constraint(|ctx):
		Role(NaBLHelp(e, _), _, _, _) -> <fail>
		where
		  <_has-annotation(?Use(task))> e
		; msg  := ["Unresolved reference: ", e, " cannot be resolved to an Entity"]
		; <_task-create-error-on-failure(|ctx, task, msg)> e
		  
		  

rules // check if there are no name collisions in attributes, roles, inverses and shortcuts
	
	entity-member-ns: _ -> [NablNsAttribute(),NablNsRole(),NablNsInverse(),NablNsShortcut()]

	nabl-constraint(|ctx):
		a -> <fail>
			where
				<is-string>a;                     //on all strings
				name := <nabl-get-name>a;         //that have an nabl name
				<not(_nabl-has-reference)>name;    //and this name is a def
				uri := <_nabl-uri> name;
				ns	:= <_nabl-uri-namespace> uri;
				<fetch(?ns)><entity-member-ns>    //and its namespace is one we want to check
			with
				<name-nses-conflict(|ctx)>name

	name-nses-conflict(|ctx): a-name -> <id>
		with
			<map(name-ns-conflict(|ctx, a-name))><entity-member-ns>

	name-ns-conflict(|ctx, a-name): conflict-ns -> <id>
		with
			uri := <_nabl-uri> a-name;
			ns	:= <_nabl-uri-namespace> uri;
			if <not(eq)> (conflict-ns, ns) then
				uri':= <_nabl-uri-parent> uri;
				parent:= <_nabl-uri-name> uri';
				parent-ns := <_nabl-uri-namespace> uri';
				role-defs := <_nabl-lookup-lexical(|ctx, conflict-ns)> a-name;
				<_task-create-error-on-success(|ctx, role-defs, ["Conflicting ", <_pp-ns>ns, " and ", <_pp-ns>conflict-ns, " ", a-name, " in ", <_pp-ns>parent-ns, " ", parent])> a-name
			end

	nabl-constraint(|ctx):
		LHSNode(NaBLHelp(e, Use()),_,_) -> <fail>
		where
		  <_has-annotation(?Use(task))> e
		; msg  := ["Unresolved reference: ", e, " cannot be resolved to a Variable"]
		; <_task-create-error-on-failure(|ctx, task, msg)> e
	nabl-constraint(|ctx):
		NHSNode(NaBLHelp(e, Use()),_,_) -> <fail>
		where
		  <_has-annotation(?Use(task))> e
		; msg  := ["Unresolved reference: ", e, " cannot be resolved to a Variable"]
		; <_task-create-error-on-failure(|ctx, task, msg)> e
	nabl-constraint(|ctx):
		RHSNode(NaBLHelp(e, Use()),_,_) -> <fail>
		where
		  <_has-annotation(?Use(task))> e
		; msg  := ["Unresolved reference: ", e, " cannot be resolved to a Variable"]
		; <_task-create-error-on-failure(|ctx, task, msg)> e
		  
	nabl-constraint(|ctx):
		LHSEdge(LHSTsHelp(_, e, _), _) -> <fail>
		where
		  <_has-annotation(?Use(task))> e
		; msg  := ["Unresolved reference: ", e, " cannot be resolved to a Role, Inverse or Shortcut"]
		; <_task-create-error-on-failure(|ctx, task, msg)> e			  
	nabl-constraint(|ctx):
		NHSEdge(NHSTsHelp(_, e, _), _) -> <fail>
		where
		  <_has-annotation(?Use(task))> e
		; msg  := ["Unresolved reference: ", e, " cannot be resolved to a Role, Inverse or Shortcut"]
		; <_task-create-error-on-failure(|ctx, task, msg)> e			  
	nabl-constraint(|ctx):
		RHSEdge(RHSTsHelp(_, e, _), _) -> <fail>
		where
		  <_has-annotation(?Use(task))> e
		; msg  := ["Unresolved reference: ", e, " cannot be resolved to a Role, Inverse or Shortcut"]
		; <_task-create-error-on-failure(|ctx, task, msg)> e	

	nabl-constraint(|ctx):
		AttrRef(a) -> <fail>
		where
		  <_has-annotation(?Use(task))> a
		; msg  := ["Unresolved reference: ", a, " cannot be resolved to a Attribute"]
		; <_task-create-error-on-failure(|ctx, task, msg)> a

	nabl-constraint(|ctx):
		CallRule(a,_) -> <fail>
		where
		  <_has-annotation(?Use(task))> a
		; msg  := ["Unresolved reference: ", a, " cannot be resolved to a Rule"]
		; <_task-create-error-on-failure(|ctx, task, msg)> a
		  
rules // check if entities have all the required attributes and roles assigned

	nabl-constraint(|ctx):
		EntityInstance(EntityRef(e-ty), e, _, as) -> <fail>
		with
			ty-def 		 := <_nabl-create-collectdefs(|ctx)> e-ty;
			[ty-attrs] := <_nabl-resolve-all-tasks(|ctx, NablNsAttribute(), [])> [ty-def];
			as-defs    := <map(?AttributeValue(AttributeRef(<_nabl-create-collectdefs(|ctx)>), _))> as;	
			as-attrs   := <_task-create-combine(|ctx)> as-defs ;
			diff       := <_task-create-diff(|ctx)> (ty-attrs, as-attrs);
			diff'      := <_nabl-create-propconstraint(|ctx, NablProp_derivation-type(), diff)> Normal();
			diff''     := <_nabl-create-propconstraint(|ctx, NablProp_multiplicity(), diff')> One();
			<_task-create-error-on-success(|ctx, diff'', ["Provide all required attributes: ", diff''])> e
			
	nabl-constraint(|ctx):
		EntityInstance(EntityRef(e-ty), e, roles, _) -> <fail>
		with
			ty-def 		 := <_nabl-create-collectdefs(|ctx)> e-ty;
			[ty-roles] := <_nabl-resolve-all-tasks(|ctx, NablNsRole(), [])> [ty-def];
			as-defs    := <map(?RoleValue(RoleRef(<_nabl-create-collectdefs(|ctx)>), _))> roles;
			as-roles   := <_task-create-combine(|ctx)> as-defs ;
			diff       := <_task-create-diff(|ctx)> (ty-roles, as-roles);
			<_task-create-error-on-success(|ctx, diff, ["Provide all required roles: ", diff])> e

rules // check if Entity (not Relation) has no roles

	nabl-constraint(|ctx):
		Entity(EntityType(), _, attributesAndRoles) -> <fail>
		with
			<filter(no-role-task(|ctx))> attributesAndRoles
			
	no-role-task(|ctx): x@Role(_,_,_,_) -> None()
		with
			<_task-create-error(|ctx, ["An entity cannot have roles."])> x

rules // check if Entity names start with a capital
	
	nabl-constraint(|ctx):
		Entity(_, x, _) -> <fail>
		with
			if not(<string-starts-with-capital> x) then
				<_task-create-warning(|ctx, ["Entity type names must start with a capital."])> x
			end
			
rules // predicates over multiplcities
	
	upper-one: ZeroOrOne() -> <id>
	upper-one: One() -> <id>
	upper-many: ZeroOrMore() -> <id>
	upper-many: OneOrMore() -> <id>
	lower-zero: ZeroOrOne() -> <id>
	lower-zero: ZeroOrMore() -> <id>
	lower-one: One() -> <id>
	lower-one: OneOrMore() -> <id>
	nullable = lower-zero
