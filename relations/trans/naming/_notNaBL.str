module _notNaBL

imports
	lib/editor-common.generated
	lib/runtime/nabl/-
	lib/runtime/properties/-
	lib/runtime/task/-
	lib/runtime/types/-

	include/Relations
	trans/naming/names
	

signature constructors
	
	Normal: DerivationType


/**
 *	Note: all these rules should go into NaBL and TS (when NaBL and TS support these)
 */

rules // unresolved references

	nabl-check-disable-unresolved = id

	nabl-constraint(|ctx):
		EntityType(e) -> <fail>
		where
		  <has-annotation(?Use(task))> e
		; msg  := ["Unresolved reference: ", e, " cannot be resolved to an EntityType"]
		; <task-create-error-on-failure(|ctx, task, msg)> e
		  
	nabl-constraint(|ctx):
		Identifier(e) -> <fail>
		where
		  <has-annotation(?Use(task))> e
		; msg  := ["Unresolved reference: ", e, " cannot be resolved to an Entity or Attribute"]
		; <task-create-error-on-failure(|ctx, task, msg)> e

		  
	nabl-constraint(|ctx):
		MemberAccess(_, e) -> <fail>
		where
		  <has-annotation(?Use(task))> e
		; msg  := ["Unresolved reference: ", e, " cannot be resolved to an Attribute"]
		; <task-create-error-on-failure(|ctx, task, msg)> e
		  
	nabl-constraint(|ctx):
		RoleName(e) -> <fail>
		where
		  <has-annotation(?Use(task))> e
		; msg  := ["Unresolved reference: ", e, " cannot be resolved to a Role"]
		; <task-create-error-on-failure(|ctx, task, msg)> e

rules // duplicate definitions : overwrite the generic one with a generic one with better error messages.
	
	nabl-check-disable-duplicate(|uri, ns) = id

	nabl-duplicate-task(|ctx, unique):
		name -> name
		where
			uri := <nabl-uri> name;
			ns	:= <nabl-uri-namespace> uri
		with
			if Unique() := unique then
				uri'		:= <nabl-uri-parent> uri;
				resolve := <nabl-create-resolvedefs(|ctx, ns, name, [])> uri';
				if(
					parent:= <nabl-uri-name> uri';
					parent-ns := <nabl-uri-namespace> uri'
				)then
					<task-create-error-on-multiple(|ctx, resolve, ["Duplicate ", <pp-ns>ns ," ", name , " in ", <pp-ns>parent-ns, " ", parent ])> name
				else
					<task-create-error-on-multiple(|ctx, resolve, ["Duplicate ", <pp-ns>ns ," ", name])> name
				end
			end

	pp-ns = write-to-string;string-replace(|"NablNs","")

rules // check if entities have all the required attributes and roles assigned

	nabl-constraint(|ctx):
		EntityOrRelation(EntityType(e-ty), e, _, as) -> <fail>
		with
			ty-def 		 := <nabl-create-collectdefs(|ctx)> e-ty;
			[ty-attrs] := <nabl-resolve-all-tasks(|ctx, NablNsAttribute(), [])> [ty-def];
			as-defs    := <map(?AttributeValue(Identifier(<nabl-create-collectdefs(|ctx)>), _))> as;	
			as-attrs   := <task-create-combine(|ctx)> as-defs ;
			diff       := <task-create-diff(|ctx)> (ty-attrs, as-attrs);
			diff'      := <nabl-create-propconstraint(|ctx, NablProp_derivation-type(), diff)> Normal();
			diff''     := <nabl-create-propconstraint(|ctx, NablProp_multiplicity(), diff')> One();
			<task-create-error-on-success(|ctx, diff'', ["Provide all required attributes: ", diff''])> e
			
	nabl-constraint(|ctx):
		EntityOrRelation(EntityType(e-ty), e, roles, _) -> <fail>
		with
			ty-def 		 := <nabl-create-collectdefs(|ctx)> e-ty;
			[ty-roles] := <nabl-resolve-all-tasks(|ctx, NablNsRole(), [])> [ty-def];
			as-defs    := <map(?RoleValue(RoleName(<nabl-create-collectdefs(|ctx)>), _))> roles;
			as-roles   := <task-create-combine(|ctx)> as-defs ;
			diff       := <task-create-diff(|ctx)> (ty-roles, as-roles);
			<task-create-error-on-success(|ctx, diff, ["Provide all required roles: ", diff])> e

rules // Entities fulfill roles

	nabl-prop-site(|lang, ctx, uris, states, implicits):
		e@EntityTypeDef(_, name, _) -> <fail>
		where
			uri := <nabl-uri> name;
			scope := <nabl-uri-parent> uri;
			allRelations := <nabl-resolve-all-tasks(|ctx, NablNsEntityType(), [])> [scope];
			roles := <nabl-resolve-all-tasks(|ctx, NablNsRole(), [Prop(Type(), name, [])]);task-create-combine(|ctx)> allRelations;
			<store-fulfill-role(|ctx, roles)> name
  
  // multiple version of names.str (generated) TODO: needs to be generated to names.str @see http://yellowgrass.org/issue/NaBL/95
  get-fulfill-role-multiple: name -> result'
  	with
  		result := <get-properties(|NablProp_fulfill-role())>name;
  		(
  			[Result(_)] := result;
  			result' := []
  		<+
  			result' := result
  		)
  		

rules // check if Entity (not Relation) has no roles

	constraint-error: EntityTypeDef(EntityType(), _, attributesAndRoles) -> <map(no-role);concat> attributesAndRoles
	no-role: x@Role(_,_,_,_) -> [(x, $[An entity cannot have roles.])]
	no-role: Attribute(_,_,_,_) -> []
	//TODO: move this to tasks

rules // check if Entity Type names start wiht a capital
	
	constraint-warning:
		EntityTypeDef(_, x, _) -> (x, $[Entity type names must start with a capital])
		where
			not(<string-starts-with-capital> x)
	//TODO: move this to tasks
			
rules // predicates over multiplcities
	
	upper-one: ZeroOrOne() -> <id>
	upper-one: One() -> <id>
	upper-many: ZeroOrMore() -> <id>
	upper-many: OneOrMore() -> <id>
	lower-zero: ZeroOrOne() -> <id>
	lower-zero: ZeroOrMore() -> <id>
	lower-one: One() -> <id>
	lower-one: OneOrMore() -> <id>
	nullable = lower-zero
