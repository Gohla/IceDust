module _notNaBL

imports
	lib/editor-common.generated
	lib/runtime/nabl/-
	lib/runtime/properties/-
	lib/runtime/task/-
	lib/runtime/types/-

	include/Relations
	trans/naming/names
	

signature constructors
	
	Normal: DerivationType


/**
 *	Note: all these rules should go into NaBL and TS (when NaBL and TS support these)
 */

rules // unresolved references manual messages

	nabl-check-disable-unresolved = id

	nabl-constraint(|ctx):
		Ref(e) -> <fail>
		where
		  <has-annotation(?Use(task))> e
		; msg  := ["Unresolved reference: ", e, " cannot be resolved to an EntityInstance, Attribute, Role, Inverse or Shortcut"]
		; <task-create-error-on-failure(|ctx, task, msg)> e

	nabl-constraint(|ctx):
		MemberAccess(_, e) -> <fail>
		where
		  <has-annotation(?Use(task))> e
		; msg  := ["Unresolved reference: ", e, " cannot be resolved to an Attribute, Role, Inverse or Shortcut"]
		; <task-create-error-on-failure(|ctx, task, msg)> e

	nabl-constraint(|ctx):
		AttributeRef(e) -> <fail>
		where
		  <has-annotation(?Use(task))> e
		; msg  := ["Unresolved reference: ", e, " cannot be resolved to an Attribute"]
		; <task-create-error-on-failure(|ctx, task, msg)> e

	nabl-constraint(|ctx):
		RoleRef(e) -> <fail>
		where
		  <has-annotation(?Use(task))> e
		; msg  := ["Unresolved reference: ", e, " cannot be resolved to a Role"]
		; <task-create-error-on-failure(|ctx, task, msg)> e

	nabl-constraint(|ctx):
		EntityRef(e) -> <fail>
		where
		  <has-annotation(?Use(task))> e
		; msg  := ["Unresolved reference: ", e, " cannot be resolved to an Entity"]
		; <task-create-error-on-failure(|ctx, task, msg)> e

	nabl-constraint(|ctx):
		EntityInstanceRef(e) -> <fail>
		where
		  <has-annotation(?Use(task))> e
		; msg  := ["Unresolved reference: ", e, " cannot be resolved to an EntityInstance"]
		; <task-create-error-on-failure(|ctx, task, msg)> e

rules // check if entities have all the required attributes and roles assigned

	nabl-constraint(|ctx):
		EntityInstance(EntityRef(e-ty), e, _, as) -> <fail>
		with
			ty-def 		 := <nabl-create-collectdefs(|ctx)> e-ty;
			[ty-attrs] := <nabl-resolve-all-tasks(|ctx, NablNsAttribute(), [])> [ty-def];
			as-defs    := <map(?AttributeValue(AttributeRef(<nabl-create-collectdefs(|ctx)>), _))> as;	
			as-attrs   := <task-create-combine(|ctx)> as-defs ;
			diff       := <task-create-diff(|ctx)> (ty-attrs, as-attrs);
			diff'      := <nabl-create-propconstraint(|ctx, NablProp_derivation-type(), diff)> Normal();
			diff''     := <nabl-create-propconstraint(|ctx, NablProp_multiplicity(), diff')> One();
			<task-create-error-on-success(|ctx, diff'', ["Provide all required attributes: ", diff''])> e
			
	nabl-constraint(|ctx):
		EntityInstance(EntityRef(e-ty), e, roles, _) -> <fail>
		with
			ty-def 		 := <nabl-create-collectdefs(|ctx)> e-ty;
			[ty-roles] := <nabl-resolve-all-tasks(|ctx, NablNsRole(), [])> [ty-def];
			as-defs    := <map(?RoleValue(RoleRef(<nabl-create-collectdefs(|ctx)>), _))> roles;
			as-roles   := <task-create-combine(|ctx)> as-defs ;
			diff       := <task-create-diff(|ctx)> (ty-roles, as-roles);
			<task-create-error-on-success(|ctx, diff, ["Provide all required roles: ", diff])> e

rules // check if Entity (not Relation) has no roles

	nabl-constraint(|ctx):
		Entity(EntityType(), _, attributesAndRoles) -> <fail>
		with
			<filter(no-role-task(|ctx))> attributesAndRoles
			
	no-role-task(|ctx): x@Role(_,_,_,_) -> None()
		with
			<task-create-error(|ctx, ["An entity cannot have roles."])> x

rules // check if Entity names start with a capital
	
	nabl-constraint(|ctx):
		Entity(_, x, _) -> <fail>
		with
			if not(<string-starts-with-capital> x) then
				<task-create-warning(|ctx, ["Entity type names must start with a capital."])> x
			end
			
rules // predicates over multiplcities
	
	upper-one: ZeroOrOne() -> <id>
	upper-one: One() -> <id>
	upper-many: ZeroOrMore() -> <id>
	upper-many: OneOrMore() -> <id>
	lower-zero: ZeroOrOne() -> <id>
	lower-zero: ZeroOrMore() -> <id>
	lower-one: One() -> <id>
	lower-one: OneOrMore() -> <id>
	nullable = lower-zero

rules // check if delete entity calls delete for all its inverses
	
	//get entity type
	//get all inverses
	//check if for all inverses a cascade of type delete is called
	nabl-constraint(|ctx):
		Operation(Delete(), op, _, cascades) -> <fail>
		with
			entity := <nabl-create-suburi(|ctx, NablNsEntity())>op;
			[model-inverses] := <nabl-resolve-all-tasks(|ctx, NablNsInverse(), [])> [entity];
			cascade-defs := <map(?Cascade(RoleOrInverse(<nabl-create-collectdefs(|ctx)>), _));task-create-combine(|ctx)> cascades;
			cascade-inverses := <nabl-create-checkdefs(|ctx, NablNsInverse())>cascade-defs;
			diff := <task-create-diff(|ctx)> (model-inverses, cascade-inverses);
			<task-create-error-on-success(|ctx, diff, ["Specify delete cascade for all inverses: ", diff])> op

rules // check if entity create calls create for relations with [1,1] or [1,n)
	
	nabl-constraint(|ctx):
		Operation(Create(), op, _, cascades) -> <fail>
		with
			entity := <nabl-create-suburi(|ctx, NablNsEntity())>op;
			[model-inverses] := <nabl-resolve-all-tasks(|ctx, NablNsInverse(), [])> [entity];
			cascade-defs := <map(?Cascade(RoleOrInverse(<nabl-create-collectdefs(|ctx)>), _));task-create-combine(|ctx)> cascades;
			cascade-inverses := <nabl-create-checkdefs(|ctx, NablNsInverse())>cascade-defs;
			missing-inverses := <task-create-diff(|ctx)> (model-inverses, cascade-inverses);
			missing-inverses-one := <nabl-create-propconstraint(|ctx, NablProp_multiplicity(), missing-inverses)> One();
			missing-inverses-oneormore := <nabl-create-propconstraint(|ctx, NablProp_multiplicity(), missing-inverses)> OneOrMore();
			missing-inverses' := <task-create-combine(|ctx)> [missing-inverses-one,missing-inverses-oneormore];
			<task-create-error-on-success(|ctx, missing-inverses', ["Specify create cascade for all inverses with multiplicity [1,1] and [1,n): ", missing-inverses'])> op


rules

	debug-task: a -> <debug>(a,<try(task-get-results)>a)
		where not(is-list)
	debug-task: a -> <debug>(a,<map(try(task-get-results))>a)
		where is-list
	debug-task(|b): a -> <debug>(b,a,<try(task-get-results)>a)
		where not(is-list)
	debug-task(|b): a -> <debug>(b,a,<map(try(task-get-results))>a)
		where is-list