module check

imports

	include/Relations
	lib/editor-common.generated
	desugar
	runtime/nabl/-
	runtime/task/-
	runtime/types/-
	names

rules
	
	constraint-warning:
		EntityTypeDef(x, _) -> (x, $[Entity type names must start with a capital])
		where
			not(<string-starts-with-capital> x)


	constraint-note:	e@Navigator(_, _)	-> (e, $[This is not translated to java yet.])
	// constraint-note:	e@Role(_, _, _)		-> (e, $[This is not translated to java yet.])
	// constraint-note:	e@RoleValue(_, _)	-> (e, $[This is not translated to java yet.])


rules // Check derivation types of attributes
	
	constraint-error:
		x@AttributeValue(AttributeName(name), _) -> (x, $[Derivations cannot be assigned custom values.])
			where
				Derivation() := <get-derivation-type>name




rules

/**
 *	Random experimenting with the task engine.
 */	
 
	// task engine based (name binding) constraints.
	nabl-constraint(|ctx):
		e@AttributeName(name) -> <fail>
    	where
    		// <debug> ["nabl-constraint", e];
			<has-annotation(?Use(task))> name;							//annotation use means that a task should be resolved
    		msg  := "Unresolved reference (from nabl-constraint task based)";
			<task-create-error-on-failure(|ctx, task, msg)> name		//if this task fails: then create the error message

	// // task engine based (name and type) constaints.
	// nabl-constraint(|ctx):
	// 	e@AttributeName(name) -> <fail>
	// 	where
	// 		lookup := <type-lookup(|ctx)> name;							// refers to a task getting the type
	// 		match  := <type-match(|ctx, "Int")> lookup;
	// 		//<debug> type;
	// 		msg := $[This attribute is of type [name]];					// TODO: how to get the type itself, instead of a task resolving to the type?
	// 		<task-create-note-on-failure(|ctx, match, msg)> name

